{"version":3,"file":"FlacParser-6S_-YEty.js","sources":["../node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js","../node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js","../node_modules/music-metadata/lib/ogg/vorbis/VorbisStream.js","../node_modules/music-metadata/lib/flac/FlacToken.js","../node_modules/music-metadata/lib/flac/FlacParser.js"],"sourcesContent":["import * as Token from 'token-types';\nimport { AttachedPictureType } from '../../id3v2/ID3v2Token.js';\n/**\n * Parse the METADATA_BLOCK_PICTURE\n * Ref: https://wiki.xiph.org/VorbisComment#METADATA_BLOCK_PICTURE\n * Ref: https://xiph.org/flac/format.html#metadata_block_picture\n * // ToDo: move to ID3 / APIC?\n */\nexport class VorbisPictureToken {\n    static fromBase64(base64str) {\n        return VorbisPictureToken.fromBuffer(Uint8Array.from(atob(base64str), c => c.charCodeAt(0)));\n    }\n    static fromBuffer(buffer) {\n        const pic = new VorbisPictureToken(buffer.length);\n        return pic.get(buffer, 0);\n    }\n    constructor(len) {\n        this.len = len;\n    }\n    get(buffer, offset) {\n        const type = AttachedPictureType[Token.UINT32_BE.get(buffer, offset)];\n        offset += 4;\n        const mimeLen = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const format = new Token.StringType(mimeLen, 'utf-8').get(buffer, offset);\n        offset += mimeLen;\n        const descLen = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const description = new Token.StringType(descLen, 'utf-8').get(buffer, offset);\n        offset += descLen;\n        const width = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const height = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const colour_depth = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const indexed_color = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const picDataLen = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const data = buffer.slice(offset, offset + picDataLen);\n        return {\n            type,\n            format,\n            description,\n            width,\n            height,\n            colour_depth,\n            indexed_color,\n            data\n        };\n    }\n}\n/**\n * Comment header decoder\n * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-620004.2.1\n */\nexport const CommonHeader = {\n    len: 7,\n    get: (buf, off) => {\n        return {\n            packetType: Token.UINT8.get(buf, off),\n            vorbis: new Token.StringType(6, 'ascii').get(buf, off + 1)\n        };\n    }\n};\n/**\n * Identification header decoder\n * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-630004.2.2\n */\nexport const IdentificationHeader = {\n    len: 23,\n    get: (uint8Array, off) => {\n        return {\n            version: Token.UINT32_LE.get(uint8Array, off + 0),\n            channelMode: Token.UINT8.get(uint8Array, off + 4),\n            sampleRate: Token.UINT32_LE.get(uint8Array, off + 5),\n            bitrateMax: Token.UINT32_LE.get(uint8Array, off + 9),\n            bitrateNominal: Token.UINT32_LE.get(uint8Array, off + 13),\n            bitrateMin: Token.UINT32_LE.get(uint8Array, off + 17)\n        };\n    }\n};\n","import * as Token from 'token-types';\nimport { textDecode } from '@borewit/text-codec';\nexport class VorbisDecoder {\n    constructor(data, offset) {\n        this.data = data;\n        this.offset = offset;\n    }\n    readInt32() {\n        const value = Token.UINT32_LE.get(this.data, this.offset);\n        this.offset += 4;\n        return value;\n    }\n    readStringUtf8() {\n        const len = this.readInt32();\n        const value = textDecode(this.data.subarray(this.offset, this.offset + len), 'utf-8');\n        this.offset += len;\n        return value;\n    }\n    parseUserComment() {\n        const offset0 = this.offset;\n        const v = this.readStringUtf8();\n        const idx = v.indexOf('=');\n        return {\n            key: v.substring(0, idx).toUpperCase(),\n            value: v.substring(idx + 1),\n            len: this.offset - offset0\n        };\n    }\n}\n","import * as Token from 'token-types';\nimport debugInit from 'debug';\nimport { VorbisDecoder } from './VorbisDecoder.js';\nimport { CommonHeader, IdentificationHeader, VorbisPictureToken } from './Vorbis.js';\nimport { makeUnexpectedFileContentError } from '../../ParseError.js';\nconst debug = debugInit('music-metadata:parser:ogg:vorbis1');\nexport class VorbisContentError extends makeUnexpectedFileContentError('Vorbis') {\n}\n/**\n * Vorbis 1 Parser.\n * Used by OggStream\n */\nexport class VorbisStream {\n    constructor(metadata, options) {\n        this.pageSegments = [];\n        this.durationOnLastPage = true;\n        this.metadata = metadata;\n        this.options = options;\n    }\n    /**\n     * Vorbis 1 parser\n     * @param header Ogg Page Header\n     * @param pageData Page data\n     */\n    async parsePage(header, pageData) {\n        this.lastPageHeader = header;\n        if (header.headerType.firstPage) {\n            this.parseFirstPage(header, pageData);\n        }\n        else {\n            if (header.headerType.continued) {\n                if (this.pageSegments.length === 0) {\n                    throw new VorbisContentError('Cannot continue on previous page');\n                }\n                this.pageSegments.push(pageData);\n            }\n            if (header.headerType.lastPage || !header.headerType.continued) {\n                // Flush page segments\n                if (this.pageSegments.length > 0) {\n                    const fullPage = VorbisStream.mergeUint8Arrays(this.pageSegments);\n                    await this.parseFullPage(fullPage);\n                }\n                // Reset page segments\n                this.pageSegments = header.headerType.lastPage ? [] : [pageData];\n            }\n        }\n    }\n    static mergeUint8Arrays(arrays) {\n        const totalSize = arrays.reduce((acc, e) => acc + e.length, 0);\n        const merged = new Uint8Array(totalSize);\n        arrays.forEach((array, i, _arrays) => {\n            const offset = _arrays.slice(0, i).reduce((acc, e) => acc + e.length, 0);\n            merged.set(array, offset);\n        });\n        return merged;\n    }\n    async flush() {\n        await this.parseFullPage(VorbisStream.mergeUint8Arrays(this.pageSegments));\n    }\n    async parseUserComment(pageData, offset) {\n        const decoder = new VorbisDecoder(pageData, offset);\n        const tag = decoder.parseUserComment();\n        await this.addTag(tag.key, tag.value);\n        return tag.len;\n    }\n    async addTag(id, value) {\n        if (id === 'METADATA_BLOCK_PICTURE' && (typeof value === 'string')) {\n            if (this.options.skipCovers) {\n                debug(\"Ignore picture\");\n                return;\n            }\n            value = VorbisPictureToken.fromBase64(value);\n            debug(`Push picture: id=${id}, format=${value.format}`);\n        }\n        else {\n            debug(`Push tag: id=${id}, value=${value}`);\n        }\n        await this.metadata.addTag('vorbis', id, value);\n    }\n    calculateDuration() {\n        if (this.lastPageHeader && this.metadata.format.sampleRate && this.lastPageHeader.absoluteGranulePosition >= 0) {\n            // Calculate duration\n            this.metadata.setFormat('numberOfSamples', this.lastPageHeader.absoluteGranulePosition);\n            this.metadata.setFormat('duration', this.lastPageHeader.absoluteGranulePosition / this.metadata.format.sampleRate);\n        }\n    }\n    /**\n     * Parse first Ogg/Vorbis page\n     * @param _header\n     * @param pageData\n     */\n    parseFirstPage(_header, pageData) {\n        this.metadata.setFormat('codec', 'Vorbis I');\n        this.metadata.setFormat('hasAudio', true);\n        debug('Parse first page');\n        // Parse  Vorbis common header\n        const commonHeader = CommonHeader.get(pageData, 0);\n        if (commonHeader.vorbis !== 'vorbis')\n            throw new VorbisContentError('Metadata does not look like Vorbis');\n        if (commonHeader.packetType === 1) {\n            const idHeader = IdentificationHeader.get(pageData, CommonHeader.len);\n            this.metadata.setFormat('sampleRate', idHeader.sampleRate);\n            this.metadata.setFormat('bitrate', idHeader.bitrateNominal);\n            this.metadata.setFormat('numberOfChannels', idHeader.channelMode);\n            debug('sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s', idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);\n        }\n        else\n            throw new VorbisContentError('First Ogg page should be type 1: the identification header');\n    }\n    async parseFullPage(pageData) {\n        // New page\n        const commonHeader = CommonHeader.get(pageData, 0);\n        debug('Parse full page: type=%s, byteLength=%s', commonHeader.packetType, pageData.byteLength);\n        switch (commonHeader.packetType) {\n            case 3: //  type 3: comment header\n                return this.parseUserCommentList(pageData, CommonHeader.len);\n            case 1: // type 1: the identification header\n            case 5: // type 5: setup header type\n                break; // ignore\n        }\n    }\n    /**\n     * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2\n     */\n    async parseUserCommentList(pageData, offset) {\n        const strLen = Token.UINT32_LE.get(pageData, offset);\n        offset += 4;\n        // const vendorString = new Token.StringType(strLen, 'utf-8').get(pageData, offset);\n        offset += strLen;\n        let userCommentListLength = Token.UINT32_LE.get(pageData, offset);\n        offset += 4;\n        while (userCommentListLength-- > 0) {\n            offset += (await this.parseUserComment(pageData, offset));\n        }\n    }\n}\n","import * as util from '../common/Util.js';\nimport { UINT16_BE, UINT24_BE, Uint8ArrayType } from 'token-types';\n/**\n * FLAC supports up to 128 kinds of metadata blocks; currently the following are defined:\n * ref: https://xiph.org/flac/format.html#metadata_block\n */\nexport const BlockType = {\n    STREAMINFO: 0, // STREAMINFO\n    PADDING: 1, // PADDING\n    APPLICATION: 2, // APPLICATION\n    SEEKTABLE: 3, // SEEKTABLE\n    VORBIS_COMMENT: 4, // VORBIS_COMMENT\n    CUESHEET: 5, // CUESHEET\n    PICTURE: 6 // PICTURE\n};\nexport const BlockHeader = {\n    len: 4,\n    get: (buf, off) => {\n        return {\n            lastBlock: util.getBit(buf, off, 7),\n            type: util.getBitAllignedNumber(buf, off, 1, 7),\n            length: UINT24_BE.get(buf, off + 1)\n        };\n    }\n};\n/**\n * METADATA_BLOCK_DATA\n * Ref: https://xiph.org/flac/format.html#metadata_block_streaminfo\n */\nexport const BlockStreamInfo = {\n    len: 34,\n    get: (buf, off) => {\n        return {\n            // The minimum block size (in samples) used in the stream.\n            minimumBlockSize: UINT16_BE.get(buf, off),\n            // The maximum block size (in samples) used in the stream.\n            // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.\n            maximumBlockSize: UINT16_BE.get(buf, off + 2) / 1000,\n            // The minimum frame size (in bytes) used in the stream.\n            // May be 0 to imply the value is not known.\n            minimumFrameSize: UINT24_BE.get(buf, off + 4),\n            // The maximum frame size (in bytes) used in the stream.\n            // May be 0 to imply the value is not known.\n            maximumFrameSize: UINT24_BE.get(buf, off + 7),\n            // Sample rate in Hz. Though 20 bits are available,\n            // the maximum sample rate is limited by the structure of frame headers to 655350Hz.\n            // Also, a value of 0 is invalid.\n            sampleRate: UINT24_BE.get(buf, off + 10) >> 4,\n            // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),\n            // (number of channels)-1. FLAC supports from 1 to 8 channels\n            channels: util.getBitAllignedNumber(buf, off + 12, 4, 3) + 1,\n            // bits per sample)-1.\n            // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.\n            bitsPerSample: util.getBitAllignedNumber(buf, off + 12, 7, 5) + 1,\n            // Total samples in stream.\n            // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.\n            // A value of zero here means the number of total samples is unknown.\n            totalSamples: util.getBitAllignedNumber(buf, off + 13, 4, 36),\n            // the MD5 hash of the file (see notes for usage... it's a littly tricky)\n            fileMD5: new Uint8ArrayType(16).get(buf, off + 18)\n        };\n    }\n};\n","import initDebug from 'debug';\nimport { Uint8ArrayType } from 'token-types';\nimport { VorbisPictureToken } from '../ogg/vorbis/Vorbis.js';\nimport { AbstractID3Parser } from '../id3v2/AbstractID3Parser.js';\nimport { FourCcToken } from '../common/FourCC.js';\nimport { VorbisStream } from '../ogg/vorbis/VorbisStream.js';\nimport { VorbisDecoder } from '../ogg/vorbis/VorbisDecoder.js';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nimport * as Flac from './FlacToken.js';\nconst debug = initDebug('music-metadata:parser:FLAC');\nclass FlacContentError extends makeUnexpectedFileContentError('FLAC') {\n}\nexport class FlacParser extends AbstractID3Parser {\n    constructor() {\n        super(...arguments);\n        this.vorbisParser = new VorbisStream(this.metadata, this.options);\n        this.padding = 0;\n    }\n    async postId3v2Parse() {\n        const fourCC = await this.tokenizer.readToken(FourCcToken);\n        if (fourCC.toString() !== 'fLaC') {\n            throw new FlacContentError('Invalid FLAC preamble');\n        }\n        let blockHeader;\n        do {\n            // Read block header\n            blockHeader = await this.tokenizer.readToken(Flac.BlockHeader);\n            // Parse block data\n            await this.parseDataBlock(blockHeader);\n        } while (!blockHeader.lastBlock);\n        if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {\n            const dataSize = this.tokenizer.fileInfo.size - this.tokenizer.position;\n            this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);\n        }\n    }\n    async parseDataBlock(blockHeader) {\n        debug(`blockHeader type=${blockHeader.type}, length=${blockHeader.length}`);\n        switch (blockHeader.type) {\n            case Flac.BlockType.STREAMINFO:\n                return this.readBlockStreamInfo(blockHeader.length);\n            case Flac.BlockType.PADDING:\n                this.padding += blockHeader.length;\n                break;\n            case Flac.BlockType.APPLICATION:\n                break;\n            case Flac.BlockType.SEEKTABLE:\n                break;\n            case Flac.BlockType.VORBIS_COMMENT:\n                return this.readComment(blockHeader.length);\n            case Flac.BlockType.CUESHEET:\n                break;\n            case Flac.BlockType.PICTURE:\n                await this.parsePicture(blockHeader.length);\n                return;\n            default:\n                this.metadata.addWarning(`Unknown block type: ${blockHeader.type}`);\n        }\n        // Ignore data block\n        return this.tokenizer.ignore(blockHeader.length).then();\n    }\n    /**\n     * Parse STREAMINFO\n     */\n    async readBlockStreamInfo(dataLen) {\n        if (dataLen !== Flac.BlockStreamInfo.len)\n            throw new FlacContentError('Unexpected block-stream-info length');\n        const streamInfo = await this.tokenizer.readToken(Flac.BlockStreamInfo);\n        this.metadata.setFormat('container', 'FLAC');\n        this.processsStreamInfo(streamInfo);\n    }\n    /**\n     * Parse STREAMINFO\n     */\n    processsStreamInfo(streamInfo) {\n        this.metadata.setFormat('codec', 'FLAC');\n        this.metadata.setFormat('hasAudio', true);\n        this.metadata.setFormat('lossless', true);\n        this.metadata.setFormat('numberOfChannels', streamInfo.channels);\n        this.metadata.setFormat('bitsPerSample', streamInfo.bitsPerSample);\n        this.metadata.setFormat('sampleRate', streamInfo.sampleRate);\n        if (streamInfo.totalSamples > 0) {\n            this.metadata.setFormat('duration', streamInfo.totalSamples / streamInfo.sampleRate);\n        }\n    }\n    /**\n     * Read VORBIS_COMMENT from tokenizer\n     * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3\n     */\n    async readComment(dataLen) {\n        const data = await this.tokenizer.readToken(new Uint8ArrayType(dataLen));\n        return this.parseComment(data);\n    }\n    /**\n     * Parse VORBIS_COMMENT\n     * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3\n     */\n    async parseComment(data) {\n        const decoder = new VorbisDecoder(data, 0);\n        const vendor = decoder.readStringUtf8();\n        if (vendor.length > 0) {\n            this.metadata.setFormat('tool', vendor);\n        }\n        const commentListLength = decoder.readInt32();\n        const tags = new Array(commentListLength);\n        for (let i = 0; i < commentListLength; i++) {\n            tags[i] = decoder.parseUserComment();\n        }\n        await Promise.all(tags.map(tag => {\n            if (tag.key === 'ENCODER') {\n                this.metadata.setFormat('tool', tag.value);\n            }\n            return this.addTag(tag.key, tag.value);\n        }));\n    }\n    async parsePicture(dataLen) {\n        if (this.options.skipCovers) {\n            return this.tokenizer.ignore(dataLen);\n        }\n        return this.addPictureTag(await this.tokenizer.readToken(new VorbisPictureToken(dataLen)));\n    }\n    addPictureTag(picture) {\n        return this.addTag('METADATA_BLOCK_PICTURE', picture);\n    }\n    addTag(id, value) {\n        return this.vorbisParser.addTag(id, value);\n    }\n}\n"],"names":["VorbisPictureToken","base64str","c","buffer","len","offset","type","AttachedPictureType","Token.UINT32_BE","mimeLen","format","Token.StringType","descLen","description","width","height","colour_depth","indexed_color","picDataLen","data","CommonHeader","buf","off","Token.UINT8","IdentificationHeader","uint8Array","Token.UINT32_LE","VorbisDecoder","value","textDecode","offset0","v","idx","debug","debugInit","VorbisContentError","makeUnexpectedFileContentError","VorbisStream","metadata","options","header","pageData","fullPage","arrays","totalSize","acc","e","merged","array","_arrays","tag","id","_header","commonHeader","idHeader","strLen","userCommentListLength","BlockType","BlockHeader","util.getBit","util.getBitAllignedNumber","UINT24_BE","BlockStreamInfo","UINT16_BE","Uint8ArrayType","initDebug","FlacContentError","FlacParser","AbstractID3Parser","FourCcToken","blockHeader","Flac.BlockHeader","dataSize","Flac.BlockType","dataLen","Flac.BlockStreamInfo","streamInfo","decoder","vendor","commentListLength","tags","i","picture"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}