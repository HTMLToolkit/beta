{"version":3,"mappings":"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","names":["visualizerStates","visualizerModules","__vitePreload","cityscape_visualizer","constellation_visualizer","cosmicpulse_visualizer","crystal_visualizer","crystalv2_visualizer","dna_visualizer","dnav2_visualizer","firespectrum_visualizer","flower_visualizer","fluid_visualizer","fluidwave_visualizer","fractal_visualizer","fracture_visualizer","fracturedcircle_visualizer","fracturedprism_visualizer","frequencyflower_visualizer","geometricpulse_visualizer","interference_visualizer","kaleidoscope_visualizer","kaleidoscopespectrogram_visualizer","layeredripplevoronoi_visualizer","liquidmetal_visualizer","matrixrain_visualizer","nebula_visualizer","neonwave_visualizer","neural_visualizer","neurospectogram_visualizer","oceanwaves_visualizer","organic_visualizer","oscilloscope_visualizer","particlefield_visualizer","pixeldust_visualizer","pulsingorbs_visualizer","quantum_visualizer","rainbowspiral_visualizer","ribbondance_visualizer","voronoi_visualizer","vortex_visualizer","water_visualizer","waterfall_visualizer","waveformrings_visualizer","waveformspectrum_visualizer","waveformtunnel_visualizer","waveinterference_visualizer","loadedVisualizers","loadVisualizer","key","path","moduleLoader","visualizer","error","getAvailableVisualizers","spectrogramTypes","getVisualizer","abstractArt","analyser","canvas","ctx","bufferLength","freqDataArray","dataType","settings","shapeColor","backgroundColor","curveScale","shapeCount","i","amplitude","architecturalBlueprint","lineColor","fillColor","margin","amplitudeThreshold","fontSize","gridSize","col","row","x","y","barGraph","dataArray","barColor","barSpacing","shadowBlur","barWidth","barHeight","biologicalCell","membraneColor","organelleColor","connectionColor","cellRadiusScale","organelleSize","centerX","centerY","cellRadius","angle","radius","prevAngle","prevX","prevY","circuitBoard","circuitColor","nodeSize","circularSpectrogram","baseColor","pointSize","radiusScale","circularWave","timeDataArray","lineWidth","waveAmplitude","value","r","cityscape","buildingColor","windowColor","buildingCount","baseHeightScale","windowRows","buildingWidth","baseHeight","freqIndex","height","rows","cols","brightness","constellationSpectrogram","pointColor","connectionCount","points","connections","p1","j","nextIndex","p2","cosmicPulse","pointInterval","v","x1","y1","x2","y2","crystalSpectrogram","branchColor","branchCount","subBranchCount","branches","baseAngle","b","subBranches","s","subAngle","subRadius","crystalSpectrogramV2","lineCount","dnaSpectrogram","strandColor","strandCount","strands","frequency","strand","progress","offset","dnaSpectrogramV2","amplitudeScale","t","wave1","wave2","intensity","fireSpectrum","gradientColors","glowIntensity","gradient","stop","color","sliceWidth","flowerSpectrogram","petalCount","petalAngle","fluidSpectrogram","particleColor","particleSize","particleLife","particleCount","velocityScale","state","p","index","fluidWaveSpectrogram","waveColor","layerCount","layers","l","layerOffset","fractalSpectrogram","_bufferLength","branchDepth","branchLength","drawBranch","startX","startY","len","depth","endX","endY","baseAmplitude","fractureSpectrogram","segmentColor","segmentCount","segments","layer","startAngle","endAngle","fracturedCircle","fracturedPrism","displacementScale","jitterInterval","jitterAmplitude","displacement","frequencyFlower","baseRadius","frequencyMesh","pointCount","numPoints","frequencyStars","starColor","starSize","threshold","size","px","py","galaxySpectrogram","armCount","arms","particlesPerArm","arm","rotation","spiral","galaxySpectrogramV2","distance","geometricPulse","shapeInterval","heightScale","interferenceSpectrogram","waveSpacing","interference","kaleidoscope","kaleidoscopeSpectrogram","mirrorCount","mirrors","m","LayeredRippleVoronoi","rippleColor","pixelSize","_","point","minDist","closestPoint","dx","dy","dist","liquidMetal","curveAmplitude","cp1x","cp1y","matrixRain","textColor","textInterval","nebulaSpectrogram","nebulaColor","neonWave","neuralSpectrogram","connectionDistance","nodes","opacity","neuroSpectrogram","nodeColor","nodesPerLayer","nodeSpacing","verticalSpacing","node","node1","layer1","node2","strength","oceanWaves","curveDepth","organicSpectrogram","growthAngle","oscilloscope","particleField","particles","particleRadius","pixelDust","pixelColor","pixelSizeScale","pixelOpacity","pulsingOrbs","orbColor","orbCount","maxRadius","spacing","quantumSpectrogram","fieldSize","probabilityThreshold","rainbowSpiral","rotationSpeed","ribbonDance","ribbonColor","ribbonCount","ribbons","sacredGeometrySpectrogram","vertices","spectrumRipple","rippleStep","spiralSpectrogram","spiralTightness","spiralSpectrogramV2","starField","starInterval","tessellationSpectrogram","tileColor","tileSize","tileShape","topwaterSpectrogram","gradientColor","ringCount","segmentStep","currentTime","ring","ringRadius","alpha","waveOffset","radiusOffset","currentRadius","innerRadius","outerRadius","voltaicArcs","arcInterval","arcHeightScale","arcHeight","voronoiSpectrum","closestColor","vortexSpectrogram","vortexScale","waterSpectrogram","connectionStep","z","widthStep","perspective","zOffset","layerPoints","freq","currentLayer","current","next","previousLayer","previous","waterfall","hueBase","saturation","lightness","scrollSpeed","imageData","hue","sat","light","waveformRings","ringColor","rings","waveformSpectrum","waveformTunnel","radiusStep","weatherSpectrogram","cloudColor","cloudHeight"],"ignoreList":[],"sources":["../../src/helpers/visualizerLoader.ts","../../src/visualizers/abstractart.visualizer.tsx","../../src/visualizers/architecturalblueprint.visualizer.tsx","../../src/visualizers/bargraph.visualizer.tsx","../../src/visualizers/biologicalcell.visualizer.tsx","../../src/visualizers/circuitboard.visualizer.tsx","../../src/visualizers/circularspectrogram.visualizer.tsx","../../src/visualizers/circularwave.visualizer.tsx","../../src/visualizers/cityscape.visualizer.tsx","../../src/visualizers/constellation.visualizer.tsx","../../src/visualizers/cosmicpulse.visualizer.tsx","../../src/visualizers/crystal.visualizer.tsx","../../src/visualizers/crystalv2.visualizer.tsx","../../src/visualizers/dna.visualizer.tsx","../../src/visualizers/dnav2.visualizer.tsx","../../src/visualizers/firespectrum.visualizer.tsx","../../src/visualizers/flower.visualizer.tsx","../../src/visualizers/fluid.visualizer.tsx","../../src/visualizers/fluidwave.visualizer.tsx","../../src/visualizers/fractal.visualizer.tsx","../../src/visualizers/fracture.visualizer.tsx","../../src/visualizers/fracturedcircle.visualizer.tsx","../../src/visualizers/fracturedprism.visualizer.tsx","../../src/visualizers/frequencyflower.visualizer.tsx","../../src/visualizers/frequencymesh.visualizer.tsx","../../src/visualizers/frequencystars.visualizer.tsx","../../src/visualizers/galaxy.visualizer.tsx","../../src/visualizers/galaxyv2.visualizer.tsx","../../src/visualizers/geometricpulse.visualizer.tsx","../../src/visualizers/interference.visualizer.tsx","../../src/visualizers/kaleidoscope.visualizer.tsx","../../src/visualizers/kaleidoscopespectrogram.visualizer.tsx","../../src/visualizers/layeredripplevoronoi.visualizer.tsx","../../src/visualizers/liquidmetal.visualizer.tsx","../../src/visualizers/matrixrain.visualizer.tsx","../../src/visualizers/nebula.visualizer.tsx","../../src/visualizers/neonwave.visualizer.tsx","../../src/visualizers/neural.visualizer.tsx","../../src/visualizers/neurospectogram.visualizer.tsx","../../src/visualizers/oceanwaves.visualizer.tsx","../../src/visualizers/organic.visualizer.tsx","../../src/visualizers/oscilloscope.visualizer.tsx","../../src/visualizers/particlefield.visualizer.tsx","../../src/visualizers/pixeldust.visualizer.tsx","../../src/visualizers/pulsingorbs.visualizer.tsx","../../src/visualizers/quantum.visualizer.tsx","../../src/visualizers/rainbowspiral.visualizer.tsx","../../src/visualizers/ribbondance.visualizer.tsx","../../src/visualizers/sacredgeometry.visualizer.tsx","../../src/visualizers/spectrumripple.visualizer.tsx","../../src/visualizers/spiralspectogram.visualizer.tsx","../../src/visualizers/spiralv2.visualizer.tsx","../../src/visualizers/starfield.visualizer.tsx","../../src/visualizers/tesselation.visualizer.tsx","../../src/visualizers/topwater.visualizer.tsx","../../src/visualizers/voltaicarcs.visualizer.tsx","../../src/visualizers/voronoi.visualizer.tsx","../../src/visualizers/vortex.visualizer.tsx","../../src/visualizers/water.visualizer.tsx","../../src/visualizers/waterfall.visualizer.tsx","../../src/visualizers/waveformrings.visualizer.tsx","../../src/visualizers/waveformspectrum.visualizer.tsx","../../src/visualizers/waveformtunnel.visualizer.tsx","../../src/visualizers/waveinterference.visualizer.tsx","../../src/visualizers/weather.visualizer.tsx"],"sourcesContent":["interface VisualizerDrawFunction {\n  (\n    analyser: AnalyserNode,\n    canvas: HTMLCanvasElement,\n    ctx: CanvasRenderingContext2D,\n    bufferLength: number,\n    dataArray: Uint8Array | Float32Array,\n    dataType: \"time\" | \"frequency\",\n    settings: Record<string, any> | undefined\n  ): void;\n}\n\nexport interface VisualizerType {\n  name: string;\n  draw: VisualizerDrawFunction;\n  dataType: \"time\" | \"frequency\";\n  settingsConfig?: Record<\n    string,\n    {\n      type: \"range\" | \"color\" | \"number\" | \"select\";\n      min?: number;\n      max?: number;\n      step?: number;\n      options?: string[];\n      default: any;\n    }\n  >;\n}\n\ninterface SpectrogramTypes {\n  [key: string]: VisualizerType;\n}\n\ninterface VisualizerState {\n  points?: { x: number; y: number; color: string; freqIndex: number }[];\n  numPoints?: number;\n  pixelSize?: number;\n  offscreen?: HTMLCanvasElement;\n  offscreenCtx?: CanvasRenderingContext2D | null;\n  config?: {\n    layers?: number;\n    sinTable?: Float32Array;\n    points?: { x: number; y: number; z: number; perspective: number }[][];\n    initialized?: boolean;\n  };\n  particles?: { x: number; y: number; vx: number; vy: number; life: number }[];\n}\n\nexport const visualizerStates: Map<string, VisualizerState> = new Map();\n\nconst visualizerModules = import.meta.glob(\"../visualizers/*.tsx\");\n\n// Cache for loaded visualizers\nconst loadedVisualizers: Map<string, VisualizerType> = new Map();\n\n// Function to dynamically load a visualizer\nexport async function loadVisualizer(key: string): Promise<VisualizerType | null> {\n  if (loadedVisualizers.has(key)) {\n    return loadedVisualizers.get(key)!;\n  }\n\n  const path = `../visualizers/${key}.visualizer.tsx`;\n  const moduleLoader = visualizerModules[path];\n  \n  if (moduleLoader) {\n    try {\n      const module = await moduleLoader();\n      const visualizer = (module as any).default;\n      if (visualizer) {\n        loadedVisualizers.set(key, visualizer);\n        return visualizer;\n      }\n    } catch (error) {\n      console.error(`Failed to load visualizer ${key}:`, error);\n    }\n  }\n  \n  return null;\n}\n\n// Function to get available visualizer keys\nexport function getAvailableVisualizers(): string[] {\n  return Object.keys(visualizerModules).map(path => \n    path.split(\"/\").pop()?.replace(\".visualizer.tsx\", \"\")\n  ).filter(Boolean) as string[];\n}\n\nexport const spectrogramTypes: SpectrogramTypes = {\n  // This object will be populated dynamically as visualizers are loaded\n};\n\n// Function to get a visualizer (loads it if not already loaded)\nexport async function getVisualizer(key: string): Promise<VisualizerType | null> {\n  if (spectrogramTypes[key]) {\n    return spectrogramTypes[key];\n  }\n  \n  const visualizer = await loadVisualizer(key);\n  if (visualizer) {\n    spectrogramTypes[key] = visualizer;\n  }\n  \n  return visualizer;\n}\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst abstractArt: VisualizerType = {\n  name: \"Abstract Art\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      shapeColor = \"hsla({hue}, 90%, 50%, {alpha})\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      curveScale = 1,\n      shapeCount = bufferLength,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    for (let i = 0; i < shapeCount; i++) {\n      const amplitude = (freqDataArray as Uint8Array)[i] / 256.0;\n\n      ctx.fillStyle = shapeColor\n        .replace(\"{hue}\", `${(i * 360) / bufferLength}`)\n        .replace(\"{alpha}\", `${amplitude}`);\n      ctx.beginPath();\n      ctx.moveTo(Math.random() * canvas.width, Math.random() * canvas.height);\n      ctx.bezierCurveTo(\n        amplitude * canvas.width * curveScale,\n        amplitude * canvas.height * curveScale,\n        (1 - amplitude) * canvas.width * curveScale,\n        (1 - amplitude) * canvas.height * curveScale,\n        Math.random() * canvas.width,\n        Math.random() * canvas.height\n      );\n      ctx.fill();\n    }\n  },\n};\n\nexport default abstractArt;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst architecturalBlueprint: VisualizerType = {\n  name: \"Architectural Blueprint\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      lineColor = \"rgba(0, 149, 255, {alpha})\",\n      fillColor = \"rgba(0, 149, 255, {alpha})\",\n      backgroundColor = \"rgba(20, 20, 20, 0.2)\",\n      margin = 50,\n      amplitudeThreshold = 0.5,\n      fontSize = 8,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const gridSize = (canvas.width - margin * 2) / Math.sqrt(bufferLength);\n\n    for (let i = 0; i < bufferLength; i++) {\n      const amplitude = freqDataArray[i] / 256.0;\n      const col = i % Math.floor(Math.sqrt(bufferLength));\n      const row = Math.floor(i / Math.floor(Math.sqrt(bufferLength)));\n\n      const x = margin + col * gridSize;\n      const y = margin + row * gridSize;\n\n      ctx.strokeStyle = lineColor.replace(\"{alpha}\", \"0.5\");\n      ctx.beginPath();\n      ctx.rect(x, y, gridSize * amplitude, gridSize * amplitude);\n      ctx.stroke();\n\n      if (amplitude > amplitudeThreshold) {\n        ctx.fillStyle = fillColor.replace(\"{alpha}\", \"0.1\");\n        ctx.beginPath();\n        ctx.arc(\n          x + gridSize / 2,\n          y + gridSize / 2,\n          (gridSize / 4) * amplitude,\n          0,\n          Math.PI * 2\n        );\n        ctx.fill();\n        ctx.stroke();\n\n        ctx.strokeStyle = lineColor.replace(\"{alpha}\", \"0.5\");\n        ctx.beginPath();\n        ctx.moveTo(x, y + gridSize + 5);\n        ctx.lineTo(x + gridSize * amplitude, y + gridSize + 5);\n        ctx.stroke();\n\n        ctx.fillStyle = lineColor.replace(\"{alpha}\", \"1.0\");\n        ctx.font = `${fontSize}px Arial`;\n        ctx.fillText(`${Math.round(amplitude * 100)}%`, x, y + gridSize + 15);\n      }\n    }\n  },\n};\n\nexport default architecturalBlueprint;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst barGraph: VisualizerType = {\n  name: \"Bar Graph\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    dataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      barColor = \"hsl({hue}, 80%, 50%)\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      barSpacing = 1,\n      shadowBlur = 5,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(dataArray as any);\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const barWidth = canvas.width / bufferLength - barSpacing;\n    let x = 0;\n\n    for (let i = 0; i < bufferLength; i++) {\n      const barHeight = (dataArray[i] / 255) * canvas.height;\n      ctx.fillStyle = barColor.replace(\"{hue}\", `${(i * 360) / bufferLength}`);\n      ctx.shadowBlur = shadowBlur;\n      ctx.shadowColor = ctx.fillStyle as string;\n      ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);\n      x += barWidth + barSpacing;\n    }\n    ctx.shadowBlur = 0;\n  },\n};\n\nexport default barGraph;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst biologicalCell: VisualizerType = {\n  name: \"Biological Cell\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      membraneColor = \"rgba(255, 255, 255, {alpha})\",\n      organelleColor = \"hsla({hue}, 70%, 50%, {alpha})\",\n      connectionColor = \"rgba(255, 255, 255, {alpha})\",\n      backgroundColor = \"rgba(20, 20, 20, 0.2)\",\n      cellRadiusScale = 0.8,\n      organelleSize = 20,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n    const cellRadius = Math.min(centerX, centerY) * cellRadiusScale;\n\n    ctx.strokeStyle = membraneColor.replace(\"{alpha}\", \"0.2\");\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, cellRadius, 0, Math.PI * 2);\n    ctx.stroke();\n\n    for (let i = 0; i < bufferLength; i++) {\n      const amplitude = freqDataArray[i] / 256.0;\n      const angle = (i * Math.PI * 2) / bufferLength;\n      const radius = cellRadius * (0.2 + amplitude * 0.6);\n\n      const x = centerX + Math.cos(angle) * radius;\n      const y = centerY + Math.sin(angle) * radius;\n\n      ctx.fillStyle = organelleColor\n        .replace(\"{hue}\", `${(i * 360) / bufferLength}`)\n        .replace(\"{alpha}\", `${amplitude}`);\n      ctx.beginPath();\n      ctx.arc(x, y, amplitude * organelleSize, 0, Math.PI * 2);\n      ctx.fill();\n\n      if (i > 0) {\n        ctx.strokeStyle = connectionColor.replace(\n          \"{alpha}\",\n          `${amplitude * 0.3}`\n        );\n        ctx.beginPath();\n        ctx.moveTo(x, y);\n        const prevAngle = ((i - 1) * Math.PI * 2) / bufferLength;\n        const prevX = centerX + Math.cos(prevAngle) * radius;\n        const prevY = centerY + Math.sin(prevAngle) * radius;\n        ctx.lineTo(prevX, prevY);\n        ctx.stroke();\n      }\n    }\n  },\n};\n\nexport default biologicalCell;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst circuitBoard: VisualizerType = {\n  name: \"Circuit Board\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      circuitColor = \"rgba(0, 255, 0, {alpha})\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      gridSize = 20,\n      nodeSize = 3,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    for (let i = 0; i < bufferLength; i++) {\n      const amplitude = freqDataArray[i] / 256.0;\n      const x = (i % (canvas.width / gridSize)) * gridSize;\n      const y = Math.floor(i / (canvas.width / gridSize)) * gridSize;\n\n      ctx.strokeStyle = circuitColor.replace(\"{alpha}\", `${amplitude}`);\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.moveTo(x, y);\n\n      if (amplitude > 0.5) {\n        ctx.lineTo(x + gridSize, y);\n        ctx.lineTo(x + gridSize, y + gridSize);\n      } else {\n        ctx.lineTo(x, y + gridSize);\n        ctx.lineTo(x + gridSize, y + gridSize);\n      }\n\n      ctx.stroke();\n\n      ctx.fillStyle = circuitColor.replace(\"{alpha}\", `${amplitude}`);\n      ctx.beginPath();\n      ctx.arc(x, y, nodeSize, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  },\n};\n\nexport default circuitBoard;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst circularSpectrogram: VisualizerType = {\n  name: \"Circular Spectrogram\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      baseColor = \"hsl({hue}, 100%, 50%)\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      pointSize = 3,\n      radiusScale = 1.0,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n    const radius = Math.min(centerX, centerY) * radiusScale - 10;\n\n    for (let i = 0; i < bufferLength; i++) {\n      const angle = (i * 2 * Math.PI) / bufferLength;\n      const amplitude = freqDataArray[i] / 256.0;\n      const x = centerX + radius * amplitude * Math.cos(angle);\n      const y = centerY + radius * amplitude * Math.sin(angle);\n\n      ctx.fillStyle = baseColor.replace(\"{hue}\", `${(i * 360) / bufferLength}`);\n      ctx.beginPath();\n      ctx.arc(x, y, pointSize, 0, 2 * Math.PI);\n      ctx.fill();\n    }\n  },\n};\n\nexport default circularSpectrogram;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst circularWave: VisualizerType = {\n  name: \"Circular Wave\",\n  dataType: \"time\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    timeDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      lineColor = \"hsl({hue}, 100%, 50%)\",\n      backgroundColor = \"rgba(0, 0, 0, 0.1)\",\n      lineWidth = 2,\n      waveAmplitude = 50,\n    } = settings;\n\n    if (dataType !== \"time\") return;\n    analyser.getByteTimeDomainData(timeDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n    const radius = Math.min(centerX, centerY) * 0.8;\n\n    ctx.beginPath();\n    for (let i = 0; i < bufferLength; i++) {\n      const angle = (i * 2 * Math.PI) / bufferLength;\n      const value = (timeDataArray as Uint8Array)[i] / 128.0 - 1;\n      const r = radius + value * waveAmplitude;\n      const x = centerX + r * Math.cos(angle);\n      const y = centerY + r * Math.sin(angle);\n\n      if (i === 0) ctx.moveTo(x, y);\n      else ctx.lineTo(x, y);\n    }\n    ctx.closePath();\n    ctx.strokeStyle = lineColor.replace(\"{hue}\", `${(Date.now() / 50) % 360}`);\n    ctx.lineWidth = lineWidth;\n    ctx.stroke();\n  },\n};\n\nexport default circularWave;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst cityscape: VisualizerType = {\n  name: \"Dynamic Cityscape\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      buildingColor = \"rgb(20, 20, {blue})\",\n      windowColor = \"rgba({brightness}, {brightness}, 0, 0.8)\",\n      backgroundColor = \"rgba(20, 20, 20, 0.2)\",\n      buildingCount = 40,\n      baseHeightScale = 0.2,\n      windowRows = 20,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const buildingWidth = canvas.width / buildingCount;\n    const baseHeight = canvas.height * baseHeightScale;\n\n    for (let i = 0; i < buildingCount; i++) {\n      const freqIndex = Math.floor((i / buildingCount) * bufferLength);\n      const height = (freqDataArray[freqIndex] / 256.0) * canvas.height * 0.7;\n\n      ctx.fillStyle = buildingColor.replace(\"{blue}\", `${30 + height / 2}`);\n      const x = i * buildingWidth;\n      ctx.fillRect(\n        x,\n        canvas.height - height - baseHeight,\n        buildingWidth - 2,\n        height\n      );\n\n      const rows = Math.floor(height / windowRows);\n      const cols = 2;\n      for (let row = 0; row < rows; row++) {\n        for (let col = 0; col < cols; col++) {\n          const brightness = Math.random() * 155 + 100;\n          ctx.fillStyle = windowColor.replace(\"{brightness}\", `${brightness}`);\n          ctx.fillRect(\n            x + col * (buildingWidth / 3) + 2,\n            canvas.height - height - baseHeight + row * windowRows + 5,\n            buildingWidth / 4,\n            windowRows / 2\n          );\n        }\n      }\n    }\n  },\n};\n\nexport default cityscape;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst constellationSpectrogram: VisualizerType = {\n  name: \"Constellation Spectrogram\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      pointColor = \"hsla({hue}, 80%, 50%, {alpha})\",\n      lineColor = \"hsla({hue}, 70%, 50%, {alpha})\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      connectionCount = 3,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const points = [];\n    const connections = connectionCount;\n\n    for (let i = 0; i < bufferLength; i += 2) {\n      const amplitude = freqDataArray[i] / 256.0;\n      const angle = (i * 2 * Math.PI) / bufferLength;\n      const radius =\n        (Math.min(canvas.width, canvas.height) / 3) * (0.5 + amplitude * 0.5);\n\n      points.push({\n        x: canvas.width / 2 + radius * Math.cos(angle),\n        y: canvas.height / 2 + radius * Math.sin(angle),\n        amplitude: amplitude,\n      });\n    }\n\n    for (let i = 0; i < points.length; i++) {\n      const p1 = points[i];\n\n      for (let j = 0; j < connections; j++) {\n        const nextIndex = (i + j + 1) % points.length;\n        const p2 = points[nextIndex];\n\n        const distance = Math.hypot(p2.x - p1.x, p2.y - p1.y);\n        if (distance < 100) {\n          ctx.beginPath();\n          ctx.moveTo(p1.x, p1.y);\n          ctx.lineTo(p2.x, p2.y);\n          ctx.strokeStyle = lineColor\n            .replace(\"{hue}\", `${(i * 360) / points.length}`)\n            .replace(\n              \"{alpha}\",\n              `${0.15 + (p1.amplitude + p2.amplitude) * 0.2}`\n            );\n          ctx.lineWidth = 1;\n          ctx.stroke();\n        }\n      }\n\n      ctx.fillStyle = pointColor\n        .replace(\"{hue}\", `${(i * 360) / points.length}`)\n        .replace(\"{alpha}\", `${0.3 + p1.amplitude * 0.7}`);\n      ctx.beginPath();\n      ctx.arc(p1.x, p1.y, 2 + p1.amplitude * 3, 0, 2 * Math.PI);\n      ctx.fill();\n    }\n  },\n};\n\nexport default constellationSpectrogram;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst cosmicPulse: VisualizerType = {\n  name: \"Cosmic Pulse\",\n  dataType: \"time\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    timeDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      pointColor = \"hsla({hue}, 80%, 50%, {alpha})\",\n      lineColor = \"hsla({hue}, 80%, 50%, 0.2)\",\n      backgroundColor = \"rgba(0, 0, 20, 0.2)\",\n      pointInterval = 8,\n      pointSize = 5,\n      radiusScale = 1.0,\n    } = settings;\n\n    if (dataType !== \"time\") return;\n    analyser.getByteTimeDomainData(timeDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n\n    for (let i = 0; i < bufferLength; i += pointInterval) {\n      const v = timeDataArray[i] / 128.0;\n      const radius = v * Math.min(centerX, centerY) * radiusScale;\n      const angle = (i * 2 * Math.PI) / bufferLength;\n\n      ctx.beginPath();\n      ctx.fillStyle = pointColor\n        .replace(\"{hue}\", `${(i / bufferLength) * 360}`)\n        .replace(\"{alpha}\", `${v * 0.5}`);\n\n      const x1 = centerX + Math.cos(angle) * radius;\n      const y1 = centerY + Math.sin(angle) * radius;\n      const x2 = centerX + Math.cos(angle + 0.2) * (radius * 0.8);\n      const y2 = centerY + Math.sin(angle + 0.2) * (radius * 0.8);\n\n      ctx.arc(x1, y1, v * pointSize, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.beginPath();\n      ctx.strokeStyle = lineColor.replace(\n        \"{hue}\",\n        `${(i / bufferLength) * 360}`\n      );\n      ctx.moveTo(x1, y1);\n      ctx.lineTo(x2, y2);\n      ctx.stroke();\n    }\n  },\n};\n\nexport default cosmicPulse;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst crystalSpectrogram: VisualizerType = {\n  name: \"Crystal Formation\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      branchColor = \"hsla({hue}, 85%, 50%, {alpha})\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      branchCount = 6,\n      subBranchCount = 3,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n    const branches = branchCount;\n\n    for (let i = 0; i < bufferLength; i++) {\n      const amplitude = freqDataArray[i] / 256.0;\n      const baseAngle = (i * 2 * Math.PI) / bufferLength;\n\n      for (let b = 0; b < branches; b++) {\n        const angle = baseAngle + (b * 2 * Math.PI) / branches;\n        const radius = Math.min(centerX, centerY) * (0.2 + amplitude * 0.8);\n\n        const x1 = centerX + radius * Math.cos(angle);\n        const y1 = centerY + radius * Math.sin(angle);\n\n        ctx.beginPath();\n        ctx.moveTo(centerX, centerY);\n        ctx.lineTo(x1, y1);\n        ctx.strokeStyle = branchColor\n          .replace(\"{hue}\", `${(i * 360) / bufferLength}`)\n          .replace(\"{alpha}\", `${0.3 + amplitude * 0.7}`);\n        ctx.lineWidth = 2 + amplitude * 3;\n        ctx.stroke();\n\n        const subBranches = subBranchCount;\n        for (let s = 0; s < subBranches; s++) {\n          const subAngle = angle + (((s - 1) * Math.PI) / 6) * amplitude;\n          const subRadius = radius * 0.3;\n\n          const x2 = x1 + subRadius * Math.cos(subAngle);\n          const y2 = y1 + subRadius * Math.sin(subAngle);\n\n          ctx.beginPath();\n          ctx.moveTo(x1, y1);\n          ctx.lineTo(x2, y2);\n          ctx.strokeStyle = branchColor\n            .replace(\"{hue}\", `${(i * 360) / bufferLength}`)\n            .replace(\"{alpha}\", `${0.2 + amplitude * 0.5}`);\n          ctx.lineWidth = 1 + amplitude * 2;\n          ctx.stroke();\n        }\n      }\n    }\n  },\n};\n\nexport default crystalSpectrogram;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst crystalSpectrogramV2: VisualizerType = {\n  name: \"Crystalline Formation\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      lineColor = \"hsla({hue}, 90%, 70%, {alpha})\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      lineCount = 5,\n      radiusScale = 200,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n\n    for (let i = 0; i < bufferLength; i++) {\n      const amplitude = freqDataArray[i] / 256.0;\n      const angle = (i * 72 * Math.PI) / 180;\n\n      for (let j = 0; j < lineCount; j++) {\n        const radius = amplitude * radiusScale + j * 30;\n        const x = centerX + radius * Math.cos(angle);\n        const y = centerY + radius * Math.sin(angle);\n\n        ctx.strokeStyle = lineColor\n          .replace(\"{hue}\", `${(i * 360) / bufferLength}`)\n          .replace(\"{alpha}\", `${amplitude}`);\n        ctx.beginPath();\n        ctx.moveTo(centerX, centerY);\n        ctx.lineTo(x, y);\n        ctx.stroke();\n      }\n    }\n  },\n};\n\nexport default crystalSpectrogramV2;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst dnaSpectrogram: VisualizerType = {\n  name: \"DNA Helix Spectrogram\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      strandColor = \"hsla({hue}, 70%, 50%, 0.8)\",\n      barColor = \"hsla({hue}, 70%, 50%, 0.3)\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      strandCount = 2,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const strands = strandCount;\n    const frequency = 2;\n    const points = bufferLength / strands;\n\n    for (let strand = 0; strand < strands; strand++) {\n      ctx.beginPath();\n\n      for (let i = 0; i < points; i++) {\n        const freqIndex = Math.floor(i + strand * points);\n        const amplitude = freqDataArray[freqIndex] / 256.0;\n\n        const progress = i / points;\n        const x = progress * canvas.width;\n        const offset = Math.PI * strand;\n        const y =\n          canvas.height / 2 +\n          Math.sin(progress * Math.PI * 2 * frequency + offset) *\n            100 *\n            (0.5 + amplitude * 0.5);\n\n        if (i === 0) {\n          ctx.moveTo(x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n\n        if (strand === 0) {\n          const y2 =\n            canvas.height / 2 +\n            Math.sin(progress * Math.PI * 2 * frequency + Math.PI) *\n              100 *\n              (0.5 + amplitude * 0.5);\n\n          ctx.fillStyle = barColor.replace(\n            \"{hue}\",\n            `${(freqIndex * 360) / bufferLength}`\n          );\n          ctx.fillRect(x, y, 2, y2 - y);\n        }\n      }\n\n      ctx.strokeStyle = strandColor.replace(\"{hue}\", `${strand * 180}`);\n      ctx.lineWidth = 3;\n      ctx.stroke();\n    }\n  },\n};\n\nexport default dnaSpectrogram;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst dnaSpectrogramV2: VisualizerType = {\n  name: \"DNA Helix\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      lineColor = \"hsla({hue}, 70%, 50%, {alpha})\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      frequency = 0.02,\n      amplitudeScale = 100,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    for (let i = 0; i < bufferLength; i++) {\n      const t = i * 5;\n      const wave1 = Math.sin(t * frequency) * amplitudeScale;\n      const wave2 = Math.sin(t * frequency + Math.PI) * amplitudeScale;\n\n      const x1 = t + canvas.width / 4;\n      const y1 = canvas.height / 2 + wave1;\n      const x2 = t + canvas.width / 4;\n      const y2 = canvas.height / 2 + wave2;\n\n      const intensity = freqDataArray[i] / 256.0;\n\n      ctx.strokeStyle = lineColor\n        .replace(\"{hue}\", `${i}`)\n        .replace(\"{alpha}\", `${intensity}`);\n      ctx.beginPath();\n      ctx.moveTo(x1, y1);\n      ctx.lineTo(x2, y2);\n      ctx.stroke();\n    }\n  },\n};\n\nexport default dnaSpectrogramV2;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst fireSpectrum: VisualizerType = {\n  name: \"Fire Spectrum\",\n  dataType: \"time\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    timeDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      gradientColors = [\n        { stop: 0, color: \"#ff0000\" },\n        { stop: 0.5, color: \"#ff8c00\" },\n        { stop: 1, color: \"#ffff00\" },\n      ],\n      backgroundColor = \"rgba(0, 0, 0, 0.2)\",\n      lineWidth = 3,\n      glowIntensity = 0.5,\n    } = settings;\n\n    if (dataType !== \"time\") return;\n    analyser.getByteTimeDomainData(timeDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);\n    gradientColors.forEach(({ stop, color }: any) =>\n      gradient.addColorStop(stop, color)\n    );\n\n    ctx.lineWidth = lineWidth;\n    ctx.strokeStyle = gradient;\n    ctx.shadowBlur = 10 * glowIntensity;\n    ctx.shadowColor = \"#ff8c00\";\n    ctx.beginPath();\n\n    const sliceWidth = canvas.width / bufferLength;\n    let x = 0;\n\n    for (let i = 0; i < bufferLength; i++) {\n      const v = timeDataArray[i] / 128.0;\n      const y = (v * canvas.height) / 2;\n\n      if (i === 0) ctx.moveTo(x, y);\n      else ctx.lineTo(x, y);\n      x += sliceWidth;\n    }\n\n    ctx.stroke();\n    ctx.shadowBlur = 0;\n  },\n};\n\nexport default fireSpectrum;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst flowerSpectrogram: VisualizerType = {\n  name: \"Flower Spectrogram\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      pointColor = \"hsla({hue}, 80%, 50%, 0.6)\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      pointSize = 3,\n      petalCount = 12,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n\n    for (let i = 0; i < bufferLength; i++) {\n      const amplitude = freqDataArray[i] / 256.0;\n      const angle = (i * 2 * Math.PI) / bufferLength;\n      const radius = Math.min(centerX, centerY) * amplitude;\n\n      const petalAngle = angle * petalCount;\n      const x = centerX + radius * Math.cos(petalAngle);\n      const y = centerY + radius * Math.sin(petalAngle);\n\n      ctx.fillStyle = pointColor.replace(\n        \"{hue}\",\n        `${(i * 360) / bufferLength}`\n      );\n      ctx.beginPath();\n      ctx.arc(x, y, pointSize, 0, 2 * Math.PI);\n      ctx.fill();\n    }\n  },\n};\n\nexport default flowerSpectrogram;\n","import { VisualizerType, visualizerStates } from \"../helpers/visualizerLoader\";\n\nconst fluidSpectrogram: VisualizerType = {\n  name: \"Fluid Dynamics\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      particleColor = \"hsla({hue}, 80%, 50%, {alpha})\",\n      backgroundColor = \"rgba(20, 20, 20, 0.2)\",\n      particleSize = 15,\n      particleLife = 0.99,\n      particleCount = 100,\n      velocityScale = 2,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    let state = visualizerStates.get(\"fluidSpectrogram\") || {};\n    if (!state.particles) {\n      state.particles = new Array(particleCount).fill(null).map(() => ({\n        x: canvas.width / 2 + Math.cos(Math.random() * 2 * Math.PI) * 100,\n        y: canvas.height / 2 + Math.sin(Math.random() * 2 * Math.PI) * 100,\n        vx: (Math.random() - 0.5) * velocityScale,\n        vy: (Math.random() - 0.5) * velocityScale,\n        life: 1.0,\n      }));\n      visualizerStates.set(\"fluidSpectrogram\", state);\n    }\n\n    analyser.getByteFrequencyData(freqDataArray as any);\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    state.particles!.forEach((p, index) => {\n      const freqIndex = index % bufferLength;\n      const amplitude = freqDataArray[freqIndex] / 256.0;\n\n      p.x += p.vx * (1 + amplitude * velocityScale);\n      p.y += p.vy * (1 + amplitude * velocityScale);\n      p.life *= particleLife;\n\n      if (p.x < 0 || p.x > canvas.width) p.vx *= -1;\n      if (p.y < 0 || p.y > canvas.height) p.vy *= -1;\n\n      if (p.life < 0.01) {\n        p.x = canvas.width / 2 + Math.cos(Math.random() * 2 * Math.PI) * 100;\n        p.y = canvas.height / 2 + Math.sin(Math.random() * 2 * Math.PI) * 100;\n        p.vx = (Math.random() - 0.5) * velocityScale;\n        p.vy = (Math.random() - 0.5) * velocityScale;\n        p.life = 1.0;\n      }\n\n      ctx.fillStyle = particleColor\n        .replace(\"{hue}\", `${(freqIndex * 360) / bufferLength}`)\n        .replace(\"{alpha}\", `${p.life * amplitude}`);\n      ctx.beginPath();\n      ctx.arc(\n        p.x,\n        p.y,\n        particleSize * p.life * (0.5 + amplitude * 0.5),\n        0,\n        Math.PI * 2\n      );\n      ctx.fill();\n    });\n  },\n};\n\nexport default fluidSpectrogram;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst fluidWaveSpectrogram: VisualizerType = {\n  name: \"Fluid Wave\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      waveColor = \"hsla({hue}, 70%, 50%, {alpha})\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      layerCount = 4,\n      lineWidth = 3,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const layers = layerCount;\n\n    for (let l = 0; l < layers; l++) {\n      ctx.beginPath();\n      const layerOffset = (l * canvas.height) / layers;\n\n      for (let i = 0; i <= bufferLength; i++) {\n        const x = (i / bufferLength) * canvas.width;\n        const freqIndex = i % bufferLength;\n        const amplitude = freqDataArray[freqIndex] / 256.0;\n\n        const wave1 = Math.sin(i * 0.1 + l * 0.5) * 30 * amplitude;\n        const wave2 = Math.cos(i * 0.05 + l * 0.3) * 20 * amplitude;\n        const y = layerOffset + wave1 + wave2;\n\n        if (i === 0) {\n          ctx.moveTo(x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n      }\n\n      const gradient = ctx.createLinearGradient(\n        0,\n        layerOffset - 50,\n        0,\n        layerOffset + 50\n      );\n      gradient.addColorStop(\n        0,\n        waveColor.replace(\"{hue}\", `${l * 90}`).replace(\"{alpha}\", \"0\")\n      );\n      gradient.addColorStop(\n        0.5,\n        waveColor.replace(\"{hue}\", `${l * 90}`).replace(\"{alpha}\", \"0.3\")\n      );\n      gradient.addColorStop(\n        1,\n        waveColor.replace(\"{hue}\", `${l * 90}`).replace(\"{alpha}\", \"0\")\n      );\n\n      ctx.strokeStyle = gradient;\n      ctx.lineWidth = lineWidth;\n      ctx.stroke();\n    }\n  },\n};\n\nexport default fluidWaveSpectrogram;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst fractalSpectrogram: VisualizerType = {\n  name: \"Fractal Tree\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    _bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      branchColor = \"hsla({hue}, 70%, 50%, {alpha})\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      branchDepth = 9,\n      branchLength = 100,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const drawBranch = (\n      startX: number,\n      startY: number,\n      len: number,\n      angle: number,\n      depth: number,\n      amplitude: number\n    ) => {\n      if (depth === 0) return;\n\n      const endX = startX + len * Math.cos(angle);\n      const endY = startY - len * Math.sin(angle);\n\n      ctx.strokeStyle = branchColor\n        .replace(\"{hue}\", `${depth * 30}`)\n        .replace(\"{alpha}\", `${amplitude}`);\n      ctx.lineWidth = depth;\n      ctx.beginPath();\n      ctx.moveTo(startX, startY);\n      ctx.lineTo(endX, endY);\n      ctx.stroke();\n\n      drawBranch(\n        endX,\n        endY,\n        len * 0.7,\n        angle + amplitude,\n        depth - 1,\n        amplitude\n      );\n      drawBranch(\n        endX,\n        endY,\n        len * 0.7,\n        angle - amplitude,\n        depth - 1,\n        amplitude\n      );\n    };\n\n    const baseAmplitude = freqDataArray[0] / 256.0;\n    drawBranch(\n      canvas.width / 2,\n      canvas.height,\n      branchLength,\n      Math.PI / 2,\n      branchDepth,\n      baseAmplitude\n    );\n  },\n};\n\nexport default fractalSpectrogram;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst fractureSpectrogram: VisualizerType = {\n  name: \"Fracture Spectrogram\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      segmentColor = \"hsla({hue}, {saturation}%, 50%, {alpha})\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      segmentCount = 16,\n      layerCount = 4,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const segments = segmentCount;\n    const layers = layerCount;\n\n    for (let layer = 0; layer < layers; layer++) {\n      const radius =\n        ((layer + 1) * Math.min(canvas.width, canvas.height)) / (layers * 2);\n\n      for (let i = 0; i < segments; i++) {\n        const freqIndex = (layer * segments + i) % bufferLength;\n        const amplitude = freqDataArray[freqIndex] / 256.0;\n\n        const startAngle =\n          (i * 2 * Math.PI) / segments + (layer * Math.PI) / (layers * 2);\n        const endAngle =\n          ((i + 1) * 2 * Math.PI) / segments + (layer * Math.PI) / (layers * 2);\n\n        ctx.beginPath();\n        ctx.arc(\n          canvas.width / 2,\n          canvas.height / 2,\n          radius * (1 + amplitude * 0.3),\n          startAngle,\n          endAngle\n        );\n\n        ctx.strokeStyle = segmentColor\n          .replace(\"{hue}\", `${(freqIndex * 360) / bufferLength}`)\n          .replace(\"{saturation}\", `${70 + amplitude * 30}`)\n          .replace(\"{alpha}\", `${0.3 + amplitude * 0.7}`);\n        ctx.lineWidth = 2 + amplitude * 4;\n        ctx.stroke();\n\n        if (amplitude > 0.5) {\n          ctx.beginPath();\n          ctx.moveTo(canvas.width / 2, canvas.height / 2);\n          ctx.lineTo(\n            canvas.width / 2 + radius * Math.cos(startAngle),\n            canvas.height / 2 + radius * Math.sin(startAngle)\n          );\n          ctx.strokeStyle = segmentColor\n            .replace(\"{hue}\", `${(freqIndex * 360) / bufferLength}`)\n            .replace(\"{saturation}\", \"70\")\n            .replace(\"{alpha}\", `${amplitude - 0.5}`);\n          ctx.stroke();\n        }\n      }\n    }\n  },\n};\n\nexport default fractureSpectrogram;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst fracturedCircle: VisualizerType = {\n  name: \"Fractured Circle\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      segmentColor = \"hsl({hue}, 70%, 50%)\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      segmentCount = 32,\n      lineWidth = 3,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n    const segments = segmentCount;\n\n    for (let i = 0; i < segments; i++) {\n      const freqIndex = Math.floor((i / segments) * bufferLength);\n      const amplitude = freqDataArray[freqIndex] / 256.0;\n      const startAngle = (i * 2 * Math.PI) / segments;\n      const endAngle = ((i + 1) * 2 * Math.PI) / segments;\n\n      const radius = Math.min(centerX, centerY) * (0.5 + amplitude * 0.5);\n\n      ctx.beginPath();\n      ctx.arc(centerX, centerY, radius, startAngle, endAngle);\n      ctx.strokeStyle = segmentColor.replace(\n        \"{hue}\",\n        `${(i * 360) / segments}`\n      );\n      ctx.lineWidth = lineWidth + amplitude * 5;\n      ctx.stroke();\n    }\n  },\n};\n\nexport default fracturedCircle;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst fracturedPrism: VisualizerType = {\n  name: \"Fractured Prism\",\n  dataType: \"time\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    timeDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      lineColor = \"hsla({hue}, 70%, 50%, 0.6)\",\n      backgroundColor = \"rgba(0, 0, 0, 0.2)\",\n      layerCount = 3,\n      displacementScale = 30,\n      jitterInterval = 5,\n      jitterAmplitude = 5,\n    } = settings;\n\n    if (dataType !== \"time\") return;\n    analyser.getByteTimeDomainData(timeDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const centerY = canvas.height / 2;\n    const sliceWidth = canvas.width / bufferLength;\n\n    for (let layer = 0; layer < layerCount; layer++) {\n      let x = 0;\n      ctx.beginPath();\n      ctx.strokeStyle = lineColor.replace(\"{hue}\", `${120 * layer}`);\n      ctx.lineWidth = 2;\n\n      for (let i = 0; i < bufferLength; i++) {\n        const v = timeDataArray[i] / 128.0;\n        const displacement =\n          Math.sin(i * 0.05 + (layer * Math.PI) / 3) * displacementScale;\n        const y = centerY + v * displacement;\n\n        if (i === 0) ctx.moveTo(x, y);\n        else if (i % jitterInterval === 0) {\n          ctx.lineTo(\n            x + Math.random() * jitterAmplitude,\n            y + Math.random() * jitterAmplitude\n          );\n        } else {\n          ctx.lineTo(x, y);\n        }\n        x += sliceWidth;\n      }\n      ctx.stroke();\n    }\n  },\n};\n\nexport default fracturedPrism;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst frequencyFlower: VisualizerType = {\n  name: \"Frequency Flower\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      lineColor = \"hsl({hue}, 100%, 50%)\",\n      backgroundColor = \"rgba(0, 0, 0, 0.1)\",\n      lineWidth = 2,\n      petalCount = 8,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n    const baseRadius = Math.min(centerX, centerY) * 0.3;\n\n    ctx.beginPath();\n    for (let i = 0; i < bufferLength; i++) {\n      const angle = (i * 2 * Math.PI) / bufferLength;\n      const value = freqDataArray[i] / 256;\n      const radius =\n        baseRadius + value * baseRadius * Math.sin(petalCount * angle);\n      const x = centerX + radius * Math.cos(angle);\n      const y = centerY + radius * Math.sin(angle);\n\n      if (i === 0) ctx.moveTo(x, y);\n      else ctx.lineTo(x, y);\n    }\n    ctx.closePath();\n    ctx.strokeStyle = lineColor.replace(\"{hue}\", `${(Date.now() / 30) % 360}`);\n    ctx.lineWidth = lineWidth;\n    ctx.stroke();\n  },\n};\n\nexport default frequencyFlower;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst frequencyMesh: VisualizerType = {\n  name: \"Frequency Mesh\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      lineColor = \"rgba(0, 255, 255, 0.5)\",\n      backgroundColor = \"black\",\n      pointCount = 20,\n      lineWidth = 1,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const points = [];\n    const numPoints = pointCount;\n\n    for (let i = 0; i < numPoints; i++) {\n      const freqIndex = Math.floor((i * bufferLength) / numPoints);\n      const value = freqDataArray[freqIndex] / 256;\n      points.push({\n        x: (canvas.width * i) / (numPoints - 1),\n        y: canvas.height / 2 + (value - 0.5) * canvas.height,\n      });\n    }\n\n    ctx.strokeStyle = lineColor;\n    ctx.lineWidth = lineWidth;\n    ctx.beginPath();\n    for (let i = 0; i < points.length; i++) {\n      for (let j = i + 1; j < points.length; j++) {\n        ctx.moveTo(points[i].x, points[i].y);\n        ctx.lineTo(points[j].x, points[j].y);\n      }\n    }\n    ctx.stroke();\n  },\n};\n\nexport default frequencyMesh;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst frequencyStars: VisualizerType = {\n  name: \"Frequency Stars\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      starColor = \"hsl({hue}, 100%, 80%)\",\n      backgroundColor = \"rgba(0, 0, 0, 0.2)\",\n      starSize = 4,\n      threshold = 128,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    for (let i = 0; i < bufferLength; i++) {\n      const value = freqDataArray[i];\n      if (value > threshold) {\n        const x = Math.random() * canvas.width;\n        const y = Math.random() * canvas.height;\n        const size = ((value - threshold) / 32) * starSize;\n\n        ctx.fillStyle = starColor.replace(\n          \"{hue}\",\n          `${(i * 360) / bufferLength}`\n        );\n        ctx.beginPath();\n        for (let j = 0; j < 5; j++) {\n          const angle = (j * 4 * Math.PI) / 5;\n          const px = x + size * Math.cos(angle);\n          const py = y + size * Math.sin(angle);\n          if (j === 0) ctx.moveTo(px, py);\n          else ctx.lineTo(px, py);\n        }\n        ctx.closePath();\n        ctx.fill();\n      }\n    }\n  },\n};\n\nexport default frequencyStars;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst galaxySpectrogram: VisualizerType = {\n  name: \"Galaxy Formation\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      particleColor = \"hsla({hue}, {saturation}%, {lightness}%, {alpha})\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      armCount = 4,\n      particleSize = 4,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n    const arms = armCount;\n    const particlesPerArm = bufferLength / arms;\n\n    for (let arm = 0; arm < arms; arm++) {\n      for (let i = 0; i < particlesPerArm; i++) {\n        const freqIndex = Math.floor(arm * particlesPerArm + i);\n        const amplitude = freqDataArray[freqIndex] / 256.0;\n\n        const rotation =\n          (i / particlesPerArm) * 2 * Math.PI + (arm * 2 * Math.PI) / arms;\n        const spiral = (i / particlesPerArm) * 5;\n        const radius =\n          (i / particlesPerArm) *\n          Math.min(centerX, centerY) *\n          (0.3 + amplitude * 0.7);\n\n        const x = centerX + radius * Math.cos(rotation + spiral);\n        const y = centerY + radius * Math.sin(rotation + spiral);\n\n        const size = 1 + amplitude * particleSize;\n\n        ctx.fillStyle = particleColor\n          .replace(\"{hue}\", `${(freqIndex * 360) / bufferLength}`)\n          .replace(\"{saturation}\", `${70 + amplitude * 30}`)\n          .replace(\"{lightness}\", `${50 + amplitude * 50}`)\n          .replace(\"{alpha}\", `${0.1 + amplitude * 0.6}`);\n        ctx.beginPath();\n        ctx.arc(x, y, size, 0, 2 * Math.PI);\n        ctx.fill();\n      }\n    }\n  },\n};\n\nexport default galaxySpectrogram;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst galaxySpectrogramV2: VisualizerType = {\n  name: \"Galaxy Spectrogram v2\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      particleColor = \"hsla({hue}, {saturation}%, {lightness}%, {alpha})\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      armCount = 4,\n      particleSize = 4,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n    const arms = armCount;\n    const particlesPerArm = bufferLength / arms;\n\n    for (let arm = 0; arm < arms; arm++) {\n      for (let i = 0; i < particlesPerArm; i++) {\n        const freqIndex = Math.floor(arm * particlesPerArm + i);\n        const amplitude = freqDataArray[freqIndex] / 256.0;\n\n        const distance = (i / particlesPerArm) * Math.min(centerX, centerY);\n        const rotation =\n          arm * ((2 * Math.PI) / arms) + (i / particlesPerArm) * 4 * Math.PI;\n\n        const x = centerX + distance * Math.cos(rotation);\n        const y = centerY + distance * Math.sin(rotation);\n\n        const size = 1 + amplitude * particleSize;\n\n        ctx.fillStyle = particleColor\n          .replace(\"{hue}\", `${(freqIndex * 360) / bufferLength}`)\n          .replace(\"{saturation}\", `${70 + amplitude * 30}`)\n          .replace(\"{lightness}\", `${50 + amplitude * 50}`)\n          .replace(\"{alpha}\", `${0.1 + amplitude * 0.4}`);\n        ctx.beginPath();\n        ctx.arc(x, y, size, 0, 2 * Math.PI);\n        ctx.fill();\n      }\n    }\n  },\n};\n\nexport default galaxySpectrogramV2;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst geometricPulse: VisualizerType = {\n  name: \"Geometric Pulse\",\n  dataType: \"time\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    timeDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      shapeColor = \"hsla({hue}, 80%, 50%, {alpha})\",\n      backgroundColor = \"rgba(0, 0, 0, 0.2)\",\n      shapeInterval = 4,\n      heightScale = 0.3,\n    } = settings;\n\n    if (dataType !== \"time\") return;\n    analyser.getByteTimeDomainData(timeDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const centerY = canvas.height / 2;\n    const sliceWidth = canvas.width / bufferLength;\n    let x = 0;\n\n    for (let i = 0; i < bufferLength; i += shapeInterval) {\n      const v = timeDataArray[i] / 128.0;\n      const height = v * canvas.height * heightScale;\n\n      ctx.beginPath();\n      ctx.fillStyle = shapeColor\n        .replace(\"{hue}\", `${(i / bufferLength) * 360}`)\n        .replace(\"{alpha}\", `${v}`);\n\n      ctx.moveTo(x, centerY);\n      ctx.lineTo(x + sliceWidth * 2, centerY - height);\n      ctx.lineTo(x + sliceWidth * 4, centerY);\n      ctx.lineTo(x + sliceWidth * 2, centerY + height);\n      ctx.closePath();\n      ctx.fill();\n\n      x += sliceWidth * shapeInterval;\n    }\n  },\n};\n\nexport default geometricPulse;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst interferenceSpectrogram: VisualizerType = {\n  name: \"Wave Interference Spectrogram\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      pointColor = \"hsla({hue}, 70%, 50%, {alpha})\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      pointSize = 2,\n      waveSpacing = 20,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    for (let i = 0; i < bufferLength; i++) {\n      const x = (i * canvas.width) / bufferLength;\n      const amplitude = freqDataArray[i] / 256.0;\n\n      for (let j = 0; j < canvas.height; j += waveSpacing) {\n        const wave1 = Math.sin(x / 50 + amplitude * 10) * 10;\n        const wave2 = Math.cos(x / 30) * 10;\n        const interference = wave1 + wave2;\n\n        ctx.fillStyle = pointColor\n          .replace(\"{hue}\", `${j + interference * 10}`)\n          .replace(\"{alpha}\", `${amplitude}`);\n        ctx.beginPath();\n        ctx.arc(x, j + interference, pointSize, 0, 2 * Math.PI);\n        ctx.fill();\n      }\n    }\n  },\n};\n\nexport default interferenceSpectrogram;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst kaleidoscope: VisualizerType = {\n  name: \"Kaleidoscope\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      pointColor = \"hsl({hue}, 100%, 50%)\",\n      backgroundColor = \"rgba(0, 0, 0, 0.1)\",\n      segmentCount = 8,\n      pointSize = 2,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n    const segments = segmentCount;\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    for (let i = 0; i < bufferLength; i += 4) {\n      const value = freqDataArray[i];\n      const radius = (value / 256) * Math.min(centerX, centerY);\n\n      for (let s = 0; s < segments; s++) {\n        const angle =\n          (s * 2 * Math.PI) / segments + (i * Math.PI) / bufferLength;\n        const x = centerX + radius * Math.cos(angle);\n        const y = centerY + radius * Math.sin(angle);\n\n        ctx.fillStyle = pointColor.replace(\n          \"{hue}\",\n          `${(i * 360) / bufferLength}`\n        );\n        ctx.beginPath();\n        ctx.arc(x, y, pointSize, 0, 2 * Math.PI);\n        ctx.fill();\n      }\n    }\n  },\n};\n\nexport default kaleidoscope;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst kaleidoscopeSpectrogram: VisualizerType = {\n  name: \"Kaleidoscope Spectrogram\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      pointColor = \"hsla({hue}, 85%, 50%, 0.5)\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      mirrorCount = 8,\n      pointSize = 3,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n    const mirrors = mirrorCount;\n\n    for (let i = 0; i < bufferLength; i++) {\n      const amplitude = freqDataArray[i] / 256.0;\n      const baseAngle = (i * 2 * Math.PI) / bufferLength;\n      const radius = Math.min(centerX, centerY) * amplitude;\n\n      for (let m = 0; m < mirrors; m++) {\n        const angle = baseAngle + (m * 2 * Math.PI) / mirrors;\n        const x = centerX + radius * Math.cos(angle);\n        const y = centerY + radius * Math.sin(angle);\n\n        ctx.fillStyle = pointColor.replace(\n          \"{hue}\",\n          `${(i * 360) / bufferLength}`\n        );\n        ctx.beginPath();\n        ctx.arc(x, y, pointSize, 0, 2 * Math.PI);\n        ctx.fill();\n      }\n    }\n  },\n};\n\nexport default kaleidoscopeSpectrogram;\n","import { VisualizerType, visualizerStates } from \"../helpers/visualizerLoader\";\n\nconst LayeredRippleVoronoi: VisualizerType = {\n  name: \"Layered Ripple Voronoi\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      rippleColor = \"hsla({hue}, 70%, 50%, 0.5)\",\n      pointColor = \"hsla({hue}, 80%, 50%, 0.6)\",\n      backgroundColor = \"rgba(0, 0, 0, 0.2)\",\n      pointCount = 20,\n      pixelSize = 4,\n      radiusScale = 0.8,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    let state = visualizerStates.get(\"LayeredRippleVoronoi\") || {};\n    if (!state.points) {\n      state = {\n        points: new Array(pointCount).fill(null).map((_, i) => ({\n          x: 0,\n          y: 0,\n          color: \"\",\n          freqIndex: Math.floor((i * 1024) / pointCount),\n        })),\n        numPoints: pointCount,\n        pixelSize: pixelSize,\n      };\n      visualizerStates.set(\"LayeredRippleVoronoi\", state);\n    }\n\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    for (let i = 0; i < bufferLength; i += 4) {\n      const value = freqDataArray[i];\n      const radius = (value / 256) * Math.min(centerX, centerY) * radiusScale;\n\n      ctx.beginPath();\n      ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);\n      ctx.strokeStyle = rippleColor.replace(\n        \"{hue}\",\n        `${(i * 360) / bufferLength}`\n      );\n      ctx.lineWidth = 2;\n      ctx.stroke();\n    }\n\n    for (let i = 0; i < state.numPoints!; i++) {\n      const point = state.points![i];\n      const value = freqDataArray[point.freqIndex];\n      const angle = (i * 2 * Math.PI) / state.numPoints!;\n      const radius = (value / 256) * Math.min(centerX, centerY) * 0.6;\n\n      point.x = centerX + Math.cos(angle) * radius;\n      point.y = centerY + Math.sin(angle) * radius;\n      point.color = pointColor.replace(\n        \"{hue}\",\n        `${(point.freqIndex * 360) / bufferLength}`\n      );\n    }\n\n    for (let x = 0; x < canvas.width; x += state.pixelSize!) {\n      for (let y = 0; y < canvas.height; y += state.pixelSize!) {\n        let minDist = Infinity;\n        let closestPoint = null;\n\n        for (let point of state.points!) {\n          const dx = x - point.x;\n          const dy = y - point.y;\n          const dist = dx * dx + dy * dy;\n          if (dist < minDist) {\n            minDist = dist;\n            closestPoint = point;\n          }\n        }\n\n        if (closestPoint) {\n          ctx.fillStyle = closestPoint.color;\n          ctx.fillRect(x, y, state.pixelSize!, state.pixelSize!);\n        }\n      }\n    }\n  },\n};\n\nexport default LayeredRippleVoronoi;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst liquidMetal: VisualizerType = {\n  name: \"Liquid Metal\",\n  dataType: \"time\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    timeDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      gradientColors = [\n        { stop: 0, color: \"#666\" },\n        { stop: 0.5, color: \"#fff\" },\n        { stop: 1, color: \"#888\" },\n      ],\n      backgroundColor = \"rgba(20, 20, 20, 0.2)\",\n      lineWidth = 4,\n      curveAmplitude = 20,\n    } = settings;\n\n    if (dataType !== \"time\") return;\n    analyser.getByteTimeDomainData(timeDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);\n    gradientColors.forEach(({ stop, color }: any) =>\n      gradient.addColorStop(stop, color)\n    );\n\n    ctx.lineWidth = lineWidth;\n    ctx.strokeStyle = gradient;\n    ctx.beginPath();\n\n    const sliceWidth = canvas.width / bufferLength;\n    let x = 0;\n\n    for (let i = 0; i < bufferLength; i++) {\n      const v = timeDataArray[i] / 128.0;\n      const y = (v * canvas.height) / 2;\n\n      if (i === 0) ctx.moveTo(x, y);\n      else {\n        const cp1x = x - sliceWidth / 2;\n        const cp1y = y + Math.sin(Date.now() / 1000 + i / 20) * curveAmplitude;\n        ctx.quadraticCurveTo(cp1x, cp1y, x, y);\n      }\n      x += sliceWidth;\n    }\n\n    ctx.stroke();\n  },\n};\n\nexport default liquidMetal;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst matrixRain: VisualizerType = {\n  name: \"Matrix Rain\",\n  dataType: \"time\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    timeDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      lineColor = \"#0f0\",\n      textColor = \"#0f0\",\n      backgroundColor = \"rgba(0, 20, 0, 0.1)\",\n      lineWidth = 2,\n      textInterval = 20,\n      fontSize = 12,\n    } = settings;\n\n    if (dataType !== \"time\") return;\n    analyser.getByteTimeDomainData(timeDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    ctx.lineWidth = lineWidth;\n    ctx.strokeStyle = lineColor;\n    ctx.beginPath();\n\n    const sliceWidth = canvas.width / bufferLength;\n    let x = 0;\n\n    for (let i = 0; i < bufferLength; i++) {\n      const v = timeDataArray[i] / 128.0;\n      const y = (v * canvas.height) / 2;\n\n      if (i === 0) {\n        ctx.moveTo(x, y);\n      } else {\n        ctx.lineTo(x, y);\n        if (i % textInterval === 0) {\n          ctx.fillStyle = textColor;\n          ctx.font = `${fontSize}px monospace`;\n          ctx.fillText(String.fromCharCode(33 + Math.random() * 93), x, y);\n        }\n      }\n      x += sliceWidth;\n    }\n\n    ctx.stroke();\n  },\n};\n\nexport default matrixRain;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst nebulaSpectrogram: VisualizerType = {\n  name: \"Cosmic Nebula\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      nebulaColor = \"hsla({hue}, 80%, 50%, {alpha})\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      radiusScale = 200,\n      pointSize = 50,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    //@ts-ignore\n    const gradient = ctx.createRadialGradient(\n      canvas.width / 2,\n      canvas.height / 2,\n      0,\n      canvas.width / 2,\n      canvas.height / 2,\n      canvas.width / 2\n    );\n\n    for (let i = 0; i < bufferLength; i++) {\n      const amplitude = freqDataArray[i] / 256.0;\n      const angle = (i * Math.PI * 2) / bufferLength;\n\n      const x = canvas.width / 2 + Math.cos(angle) * (amplitude * radiusScale);\n      const y = canvas.height / 2 + Math.sin(angle) * (amplitude * radiusScale);\n\n      ctx.fillStyle = nebulaColor\n        .replace(\"{hue}\", `${270 + i}`)\n        .replace(\"{alpha}\", `${amplitude * 0.1}`);\n      ctx.beginPath();\n      ctx.arc(x, y, amplitude * pointSize, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  },\n};\n\nexport default nebulaSpectrogram;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst neonWave: VisualizerType = {\n  name: \"Neon Wave\",\n  dataType: \"time\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    timeDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      lineColor = \"hsl({hue}, 100%, 50%)\",\n      backgroundColor = \"rgba(0, 0, 0, 0.2)\",\n      lineWidth = 3,\n      glowIntensity = 0.5,\n    } = settings;\n\n    if (dataType !== \"time\") return;\n    analyser.getByteTimeDomainData(timeDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    ctx.lineWidth = lineWidth;\n    ctx.strokeStyle = lineColor.replace(\"{hue}\", `${Date.now() % 360}`);\n    ctx.shadowBlur = 10 * glowIntensity;\n    ctx.shadowColor = ctx.strokeStyle as string;\n    ctx.beginPath();\n\n    const sliceWidth = canvas.width / bufferLength;\n    let x = 0;\n\n    for (let i = 0; i < bufferLength; i++) {\n      const v = timeDataArray[i] / 128.0;\n      const y = (v * canvas.height) / 2;\n\n      if (i === 0) ctx.moveTo(x, y);\n      else ctx.lineTo(x, y);\n      x += sliceWidth;\n    }\n\n    ctx.stroke();\n    ctx.shadowBlur = 0;\n  },\n};\n\nexport default neonWave;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst neuralSpectrogram: VisualizerType = {\n  name: \"Neural Network Visualization\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      lineColor = \"rgba(0, 255, 255, {alpha})\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      connectionDistance = 100,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const nodes = [];\n    const connections = Math.floor(bufferLength / 4);\n\n    for (let i = 0; i < connections; i++) {\n      const x = (canvas.width / connections) * i;\n      const y = canvas.height / 2 + (freqDataArray[i] - 128) * 1.5;\n      nodes.push({ x, y });\n\n      for (let j = 0; j < nodes.length; j++) {\n        const distance = Math.hypot(nodes[j].x - x, nodes[j].y - y);\n        if (distance < connectionDistance) {\n          const opacity = 1 - distance / connectionDistance;\n          ctx.strokeStyle = lineColor.replace(\"{alpha}\", `${opacity}`);\n          ctx.beginPath();\n          ctx.moveTo(x, y);\n          ctx.lineTo(nodes[j].x, nodes[j].y);\n          ctx.stroke();\n        }\n      }\n    }\n  },\n};\n\nexport default neuralSpectrogram;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst neuroSpectrogram: VisualizerType = {\n  name: \"Neural Network Spectrogram\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      nodeColor = \"hsla({hue}, 80%, 50%, {alpha})\",\n      lineColor = \"hsla({hue}, 70%, 50%, {alpha})\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      nodesPerLayer = 8,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const layers = 3;\n    const nodeSpacing = canvas.width / (layers + 1);\n    const verticalSpacing = canvas.height / (nodesPerLayer + 1);\n\n    const nodes = [];\n\n    for (let layer = 0; layer < layers; layer++) {\n      for (let node = 0; node < nodesPerLayer; node++) {\n        const freqIndex = (layer * nodesPerLayer + node) % bufferLength;\n        const amplitude = freqDataArray[freqIndex] / 256.0;\n\n        nodes.push({\n          x: nodeSpacing * (layer + 1),\n          y: verticalSpacing * (node + 1),\n          amplitude: amplitude,\n        });\n      }\n    }\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node1 = nodes[i];\n      const layer1 = Math.floor(i / nodesPerLayer);\n\n      if (layer1 < layers - 1) {\n        for (let j = 0; j < nodesPerLayer; j++) {\n          const nextIndex = (layer1 + 1) * nodesPerLayer + j;\n          const node2 = nodes[nextIndex];\n\n          const strength = (node1.amplitude + node2.amplitude) / 2;\n\n          ctx.beginPath();\n          ctx.moveTo(node1.x, node1.y);\n          ctx.lineTo(node2.x, node2.y);\n          ctx.strokeStyle = lineColor\n            .replace(\"{hue}\", `${(i * 360) / nodes.length}`)\n            .replace(\"{alpha}\", `${0.1 + strength * 0.3}`);\n          ctx.lineWidth = strength * 2;\n          ctx.stroke();\n        }\n      }\n\n      ctx.fillStyle = nodeColor\n        .replace(\"{hue}\", `${(i * 360) / nodes.length}`)\n        .replace(\"{alpha}\", `${0.3 + node1.amplitude * 0.7}`);\n      ctx.beginPath();\n      ctx.arc(node1.x, node1.y, 3 + node1.amplitude * 5, 0, 2 * Math.PI);\n      ctx.fill();\n    }\n  },\n};\n\nexport default neuroSpectrogram;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst oceanWaves: VisualizerType = {\n  name: \"Ocean Waves\",\n  dataType: \"time\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    timeDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      lineColor = \"rgba(0, 150, 255, 0.8)\",\n      backgroundColor = \"rgba(0, 50, 100, 0.2)\",\n      lineWidth = 4,\n      curveDepth = 10,\n    } = settings;\n\n    if (dataType !== \"time\") return;\n    analyser.getByteTimeDomainData(timeDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    ctx.lineWidth = lineWidth;\n    ctx.strokeStyle = lineColor;\n    ctx.beginPath();\n\n    const sliceWidth = canvas.width / bufferLength;\n    let x = 0;\n\n    for (let i = 0; i < bufferLength; i++) {\n      const v = timeDataArray[i] / 128.0;\n      const y = (v * canvas.height) / 2;\n\n      if (i === 0) ctx.moveTo(x, y);\n      else {\n        ctx.quadraticCurveTo(x - sliceWidth / 2, y - curveDepth, x, y);\n      }\n      x += sliceWidth;\n    }\n\n    ctx.stroke();\n  },\n};\n\nexport default oceanWaves;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst organicSpectrogram: VisualizerType = {\n  name: \"Organic Growth Spectrogram\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      pointColor = \"hsla({hue}, 80%, 50%, {alpha})\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      pointSize = 5,\n      growthAngle = 137.5,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n\n    for (let i = 0; i < bufferLength; i++) {\n      const angle = (i * growthAngle * Math.PI) / 180;\n      const amplitude = freqDataArray[i] / 256.0;\n      const radius = (amplitude * i) / 2;\n\n      const x = centerX + radius * Math.cos(angle);\n      const y = centerY + radius * Math.sin(angle);\n\n      ctx.fillStyle = pointColor\n        .replace(\"{hue}\", `${(i * 360) / bufferLength}`)\n        .replace(\"{alpha}\", `${amplitude}`);\n      ctx.beginPath();\n      ctx.arc(x, y, amplitude * pointSize, 0, 2 * Math.PI);\n      ctx.fill();\n    }\n  },\n};\n\nexport default organicSpectrogram;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst oscilloscope: VisualizerType = {\n  name: \"Oscilloscope\",\n  dataType: \"time\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    timeDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      lineColor = \"rgb(0, 255, 0)\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      lineWidth = 3,\n      glowIntensity = 0.5,\n    } = settings;\n\n    if (dataType !== \"time\") return;\n    analyser.getByteTimeDomainData(timeDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    ctx.lineWidth = lineWidth;\n    ctx.strokeStyle = lineColor;\n    ctx.shadowBlur = 10 * glowIntensity;\n    ctx.shadowColor = lineColor;\n    ctx.beginPath();\n\n    const sliceWidth = canvas.width / bufferLength;\n    let x = 0;\n\n    for (let i = 0; i < bufferLength; i++) {\n      const v = timeDataArray[i] / 128.0;\n      const y = (v * canvas.height) / 2;\n\n      if (i === 0) ctx.moveTo(x, y);\n      else ctx.lineTo(x, y);\n\n      x += sliceWidth;\n    }\n\n    ctx.lineTo(canvas.width, canvas.height / 2);\n    ctx.stroke();\n    ctx.shadowBlur = 0;\n  },\n};\n\nexport default oscilloscope;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst particleField: VisualizerType = {\n  name: \"Particle Field\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      particleColor = \"hsla({hue}, {saturation}%, {lightness}%, {alpha})\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      particleCount = 100,\n      baseRadius = 0.25,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const particles = particleCount;\n    const radius = Math.min(canvas.width, canvas.height) * baseRadius;\n\n    for (let i = 0; i < particles; i++) {\n      const freqIndex = Math.floor((i / particles) * bufferLength);\n      const amplitude = freqDataArray[freqIndex] / 256.0;\n      const angle = (i * 2 * Math.PI) / particles;\n\n      const particleRadius = radius + amplitude * 100;\n      const x = canvas.width / 2 + particleRadius * Math.cos(angle);\n      const y = canvas.height / 2 + particleRadius * Math.sin(angle);\n\n      const size = 2 + amplitude * 5;\n\n      ctx.fillStyle = particleColor\n        .replace(\"{hue}\", `${(freqIndex * 360) / bufferLength}`)\n        .replace(\"{saturation}\", `${80 + amplitude * 20}`)\n        .replace(\"{lightness}\", `${50 + amplitude * 50}`)\n        .replace(\"{alpha}\", `${0.3 + amplitude * 0.7}`);\n      ctx.beginPath();\n      ctx.arc(x, y, size, 0, 2 * Math.PI);\n      ctx.fill();\n    }\n  },\n};\n\nexport default particleField;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst pixelDust: VisualizerType = {\n  name: \"Pixel Dust\",\n  dataType: \"time\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    timeDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      pixelColor = \"hsl({hue}, 70%, 50%)\",\n      backgroundColor = \"rgba(0, 0, 0, 0.2)\",\n      pixelSizeScale = 8,\n      pixelOpacity = 1.0,\n    } = settings;\n\n    if (dataType !== \"time\") return;\n    analyser.getByteTimeDomainData(timeDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const sliceWidth = canvas.width / bufferLength;\n    let x = 0;\n\n    for (let i = 0; i < bufferLength; i++) {\n      const v = timeDataArray[i] / 128.0;\n      const y = (v * canvas.height) / 2;\n\n      const pixelSize = Math.abs(v - 1) * pixelSizeScale;\n      ctx.fillStyle = pixelColor\n        .replace(\"{hue}\", `${(i / bufferLength) * 360}`)\n        .replace(\"{alpha}\", `${pixelOpacity}`);\n      ctx.fillRect(x, y - pixelSize / 2, pixelSize, pixelSize);\n\n      x += sliceWidth;\n    }\n  },\n};\n\nexport default pixelDust;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst pulsingOrbs: VisualizerType = {\n  name: \"Pulsing Orbs\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      orbColor = \"hsl({hue}, 80%, 50%)\",\n      backgroundColor = \"rgba(0, 0, 0, 0.2)\",\n      orbCount = 12,\n      maxRadius = 0.5,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const spacing = canvas.width / orbCount;\n\n    for (let i = 0; i < orbCount; i++) {\n      const freqIndex = Math.floor((i * bufferLength) / orbCount);\n      const value = freqDataArray[freqIndex];\n      const radius = (value / 256) * spacing * maxRadius;\n\n      ctx.fillStyle = orbColor.replace(\"{hue}\", `${(i * 360) / orbCount}`);\n      ctx.beginPath();\n      ctx.arc(spacing * (i + 0.5), canvas.height / 2, radius, 0, 2 * Math.PI);\n      ctx.fill();\n    }\n  },\n};\n\nexport default pulsingOrbs;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst quantumSpectrogram: VisualizerType = {\n  name: \"Quantum Field\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      pointColor = \"hsla({hue}, 90%, 50%, {alpha})\",\n      lineColor = \"rgba(255, 255, 255, {alpha})\",\n      backgroundColor = \"rgba(20, 20, 20, 0.2)\",\n      fieldSize = 20,\n      probabilityThreshold = 0.5,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const cols = Math.floor(canvas.width / fieldSize);\n    const rows = Math.floor(canvas.height / fieldSize);\n\n    for (let i = 0; i < cols; i++) {\n      for (let j = 0; j < rows; j++) {\n        const freqIndex = Math.floor((i + j) % bufferLength);\n        const amplitude = freqDataArray[freqIndex] / 256.0;\n        const probability = Math.random() * amplitude;\n\n        if (probability > probabilityThreshold) {\n          const x = i * fieldSize + fieldSize / 2;\n          const y = j * fieldSize + fieldSize / 2;\n\n          ctx.fillStyle = pointColor\n            .replace(\"{hue}\", `${(freqIndex * 360) / bufferLength}`)\n            .replace(\"{alpha}\", `${amplitude}`);\n          ctx.beginPath();\n          ctx.arc(x, y, amplitude * fieldSize * 0.5, 0, Math.PI * 2);\n          ctx.fill();\n\n          if (i > 0 && j > 0) {\n            ctx.strokeStyle = lineColor.replace(\n              \"{alpha}\",\n              `${amplitude * 0.2}`\n            );\n            ctx.beginPath();\n            ctx.moveTo(x, y);\n            ctx.lineTo(x - fieldSize, y - fieldSize);\n            ctx.stroke();\n          }\n        }\n      }\n    }\n  },\n};\n\nexport default quantumSpectrogram;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst rainbowSpiral: VisualizerType = {\n  name: \"Rainbow Spiral\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      pointColor = \"hsl({hue}, 100%, 50%)\",\n      backgroundColor = \"rgba(0, 0, 0, 0.1)\",\n      pointSize = 2,\n      rotationSpeed = 1,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n\n    for (let i = 0; i < bufferLength; i++) {\n      const value = freqDataArray[i];\n      const radius = (value / 256) * Math.min(centerX, centerY);\n      const angle =\n        (i * 2 * Math.PI) / bufferLength + Date.now() / (1000 / rotationSpeed);\n\n      const x = centerX + radius * Math.cos(angle);\n      const y = centerY + radius * Math.sin(angle);\n\n      ctx.fillStyle = pointColor.replace(\n        \"{hue}\",\n        `${(i * 360) / bufferLength}`\n      );\n      ctx.beginPath();\n      ctx.arc(x, y, pointSize, 0, 2 * Math.PI);\n      ctx.fill();\n    }\n  },\n};\n\nexport default rainbowSpiral;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst ribbonDance: VisualizerType = {\n  name: \"Ribbon Dance\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      ribbonColor = \"hsla({hue}, 70%, 50%, 0.6)\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      ribbonCount = 3,\n      lineWidth = 3,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const ribbons = ribbonCount;\n    const points = bufferLength / ribbons;\n\n    for (let r = 0; r < ribbons; r++) {\n      ctx.beginPath();\n      for (let i = 0; i < points; i++) {\n        const freqIndex = Math.floor(i + r * points);\n        const amplitude = freqDataArray[freqIndex] / 256.0;\n\n        const x = (i / points) * canvas.width;\n        const y =\n          canvas.height / 2 + Math.sin(i * 0.1 + r * 2) * 100 * amplitude;\n\n        if (i === 0) {\n          ctx.moveTo(x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n      }\n      ctx.strokeStyle = ribbonColor.replace(\"{hue}\", `${r * 120}`);\n      ctx.lineWidth = lineWidth;\n      ctx.stroke();\n    }\n  },\n};\n\nexport default ribbonDance;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst sacredGeometrySpectrogram: VisualizerType = {\n  name: \"Sacred Geometry\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      lineColor = \"hsla({hue}, 70%, 50%, {alpha})\",\n      backgroundColor = \"rgba(20, 20, 20, 0.2)\",\n      layerCount = 5,\n      radiusScale = 0.8,\n      amplitudeScale = 0.3,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n    const maxRadius = Math.min(centerX, centerY) * radiusScale;\n\n    for (let layer = 0; layer < layerCount; layer++) {\n      const vertices = layer * 3 + 3;\n      const radius = maxRadius * (1 - layer * 0.15);\n\n      ctx.beginPath();\n      for (let i = 0; i < vertices; i++) {\n        const freqIndex = Math.floor((i * bufferLength) / vertices);\n        const amplitude = freqDataArray[freqIndex] / 256.0;\n        const angle = (i * Math.PI * 2) / vertices;\n\n        const x =\n          centerX +\n          Math.cos(angle) * (radius * (1 + amplitude * amplitudeScale));\n        const y =\n          centerY +\n          Math.sin(angle) * (radius * (1 + amplitude * amplitudeScale));\n\n        if (i === 0) {\n          ctx.moveTo(x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n      }\n      ctx.closePath();\n      ctx.strokeStyle = lineColor\n        .replace(\"{hue}\", `${layer * 72}`)\n        .replace(\"{alpha}\", `${0.5 + layer * 0.1}`);\n      ctx.stroke();\n\n      if (layer > 0) {\n        for (let i = 0; i < vertices; i++) {\n          const freqIndex = Math.floor((i * bufferLength) / vertices);\n          const amplitude = freqDataArray[freqIndex] / 256.0;\n          const angle = (i * Math.PI * 2) / vertices;\n\n          ctx.beginPath();\n          ctx.moveTo(centerX, centerY);\n          const x =\n            centerX +\n            Math.cos(angle) * (radius * (1 + amplitude * amplitudeScale));\n          const y =\n            centerY +\n            Math.sin(angle) * (radius * (1 + amplitude * amplitudeScale));\n          ctx.lineTo(x, y);\n          ctx.strokeStyle = lineColor\n            .replace(\"{hue}\", `${layer * 72}`)\n            .replace(\"{alpha}\", `${amplitude * 0.3}`);\n          ctx.stroke();\n        }\n      }\n    }\n  },\n};\n\nexport default sacredGeometrySpectrogram;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst spectrumRipple: VisualizerType = {\n  name: \"Spectrum Ripple\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      rippleColor = \"hsla({hue}, 100%, 50%, 0.5)\",\n      backgroundColor = \"rgba(0, 0, 0, 0.1)\",\n      lineWidth = 2,\n      rippleStep = 4,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n\n    for (let i = 0; i < bufferLength; i += rippleStep) {\n      const value = freqDataArray[i];\n      const radius = (value / 256) * Math.min(centerX, centerY);\n\n      ctx.beginPath();\n      ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);\n      ctx.strokeStyle = rippleColor.replace(\n        \"{hue}\",\n        `${(i * 360) / bufferLength}`\n      );\n      ctx.lineWidth = lineWidth;\n      ctx.stroke();\n    }\n  },\n};\n\nexport default spectrumRipple;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst spiralSpectrogram: VisualizerType = {\n  name: \"Spiral Spectrogram\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      pointColor = \"hsl({hue}, 100%, 50%)\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      pointSize = 5,\n      spiralTightness = 0.1,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n    let radius = 10;\n\n    for (let i = 0; i < bufferLength; i++) {\n      const angle = (i * 2 * Math.PI) / 64;\n      const amplitude = freqDataArray[i] / 256.0;\n      radius += spiralTightness;\n\n      const x = centerX + radius * Math.cos(angle);\n      const y = centerY + radius * Math.sin(angle);\n\n      ctx.fillStyle = pointColor.replace(\"{hue}\", `${freqDataArray[i]}`);\n      ctx.beginPath();\n      ctx.arc(x, y, amplitude * pointSize, 0, 2 * Math.PI);\n      ctx.fill();\n    }\n  },\n};\n\nexport default spiralSpectrogram;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst spiralSpectrogramV2: VisualizerType = {\n  name: \"Spiral Spectrogram v2\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      pointColor = \"hsl({hue}, {saturation}%, 50%)\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      pointSize = 2,\n      spiralTightness = 0.5,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n    const maxRadius = Math.min(centerX, centerY);\n\n    for (let i = 0; i < bufferLength; i++) {\n      const amplitude = freqDataArray[i] / 256.0;\n      const angle = (i * 2 * Math.PI) / 64;\n      const radius =\n        (i / bufferLength) * maxRadius * spiralTightness + amplitude * 50;\n\n      const x = centerX + radius * Math.cos(angle);\n      const y = centerY + radius * Math.sin(angle);\n\n      ctx.fillStyle = pointColor\n        .replace(\"{hue}\", `${(i * 360) / bufferLength}`)\n        .replace(\"{saturation}\", `${amplitude * 100}`);\n      ctx.beginPath();\n      ctx.arc(x, y, pointSize, 0, 2 * Math.PI);\n      ctx.fill();\n    }\n  },\n};\n\nexport default spiralSpectrogramV2;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst starField: VisualizerType = {\n  name: \"Star Field\",\n  dataType: \"time\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    timeDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      lineColor = \"rgba(255, 255, 255, 0.8)\",\n      starColor = \"rgba(255, 255, 255, {alpha})\",\n      backgroundColor = \"rgba(0, 0, 20, 0.3)\",\n      lineWidth = 2,\n      starInterval = 15,\n      starSize = 2,\n    } = settings;\n\n    if (dataType !== \"time\") return;\n    analyser.getByteTimeDomainData(timeDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    ctx.lineWidth = lineWidth;\n    ctx.strokeStyle = lineColor;\n    ctx.beginPath();\n\n    const sliceWidth = canvas.width / bufferLength;\n    let x = 0;\n\n    for (let i = 0; i < bufferLength; i++) {\n      const v = timeDataArray[i] / 128.0;\n      const y = (v * canvas.height) / 2;\n\n      if (i === 0) ctx.moveTo(x, y);\n      else ctx.lineTo(x, y);\n\n      if (i % starInterval === 0) {\n        ctx.fillStyle = starColor.replace(\"{alpha}\", `${Math.random()}`);\n        ctx.fillRect(x, Math.random() * canvas.height, starSize, starSize);\n      }\n      x += sliceWidth;\n    }\n\n    ctx.stroke();\n  },\n};\n\nexport default starField;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst tessellationSpectrogram: VisualizerType = {\n  name: \"Tessellation Spectrogram\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      tileColor = \"hsla({hue}, 70%, 50%, {alpha})\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      tileSize = 30,\n      tileShape = \"hexagon\",\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    for (let i = 0; i < bufferLength; i++) {\n      const x = (i % (canvas.width / tileSize)) * tileSize;\n      const y = Math.floor(i / (canvas.width / tileSize)) * tileSize;\n      const amplitude = freqDataArray[i] / 256.0;\n\n      ctx.fillStyle = tileColor\n        .replace(\"{hue}\", `${amplitude * 360}`)\n        .replace(\"{alpha}\", `${amplitude}`);\n      ctx.beginPath();\n      if (tileShape === \"hexagon\") {\n        for (let j = 0; j < 6; j++) {\n          const angle = (j * Math.PI) / 3;\n          const px = x + tileSize * Math.cos(angle);\n          const py = y + tileSize * Math.sin(angle);\n          j === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);\n        }\n      } else {\n        ctx.rect(x, y, tileSize, tileSize);\n      }\n      ctx.closePath();\n      ctx.fill();\n    }\n  },\n};\n\nexport default tessellationSpectrogram;\n","import { VisualizerType, visualizerStates } from \"../helpers/visualizerLoader\";\n\nconst topwaterSpectrogram: VisualizerType = {\n  name: \"Top-Down Water Spectrogram\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      lineColor = \"rgba(0, 255, 255, {alpha})\",\n      gradientColor = \"rgba(0, 255, 255, {alpha})\",\n      backgroundColor = \"rgba(20, 20, 20, 0.2)\",\n      ringCount = 10,\n      radiusScale = 0.4,\n      waveAmplitude = 30,\n      segmentStep = 4,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    let state = visualizerStates.get(\"topwaterSpectrogram\") || {};\n    if (!state.config) {\n      state.config = {\n        sinTable: new Float32Array(360),\n        initialized: false,\n      };\n      for (let i = 0; i < 360; i++) {\n        state.config.sinTable![i] = Math.sin((i * Math.PI) / 180);\n      }\n      state.config.initialized = true;\n      visualizerStates.set(\"topwaterSpectrogram\", state);\n    }\n\n    analyser.getByteFrequencyData(freqDataArray as any);\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const currentTime = Date.now() / 1000;\n    const radius = Math.min(canvas.width, canvas.height) * radiusScale;\n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n    const segments = Math.floor(bufferLength / segmentStep);\n\n    for (let ring = 0; ring < ringCount; ring++) {\n      const ringRadius = radius - ring * 20;\n      const alpha = 1 - ring * 0.1;\n\n      ctx.beginPath();\n      for (let i = 0; i <= segments; i++) {\n        const angle = (i / segments) * Math.PI * 2;\n        const freqIndex = i % bufferLength;\n        const frequency = freqDataArray[freqIndex];\n\n        const waveOffset =\n          state.config!.sinTable![\n            Math.floor(\n              ((currentTime * 2 + ring + i / 5) % (Math.PI * 2)) *\n                (180 / Math.PI)\n            ) % 360\n          ] * 10;\n        const radiusOffset = (frequency / 255) * waveAmplitude + waveOffset;\n        const currentRadius = ringRadius + radiusOffset;\n\n        const x = centerX + Math.cos(angle) * currentRadius;\n        const y = centerY + Math.sin(angle) * currentRadius;\n\n        if (i === 0) {\n          ctx.moveTo(x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n      }\n      ctx.closePath();\n\n      ctx.strokeStyle = lineColor.replace(\"{alpha}\", `${alpha * 0.8}`);\n      ctx.lineWidth = 2;\n      ctx.stroke();\n\n      const innerRadius = Math.max(0, ringRadius - 20);\n      let outerRadius = Math.max(0, ringRadius + 20);\n      if (outerRadius < innerRadius) {\n        outerRadius = innerRadius; // avoid invalid gradient params\n      }\n      const gradient = ctx.createRadialGradient(\n        centerX,\n        centerY,\n        innerRadius,\n        centerX,\n        centerY,\n        outerRadius\n      );\n      gradient.addColorStop(\n        0,\n        gradientColor.replace(\"{alpha}\", `${alpha * 0.1}`)\n      );\n      gradient.addColorStop(1, gradientColor.replace(\"{alpha}\", \"0\"));\n      ctx.fillStyle = gradient;\n      ctx.fill();\n    }\n  },\n};\n\nexport default topwaterSpectrogram;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst voltaicArcs: VisualizerType = {\n  name: \"Voltaic Arcs\",\n  dataType: \"time\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    timeDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      lineColor = \"rgba(0, {green}, {blue}, 0.8)\",\n      backgroundColor = \"rgba(0, 0, 0, 0.2)\",\n      lineWidth = 2,\n      arcInterval = 10,\n      arcHeightScale = 50,\n    } = settings;\n\n    if (dataType !== \"time\") return;\n    analyser.getByteTimeDomainData(timeDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const sliceWidth = canvas.width / bufferLength;\n    let x = 0;\n\n    ctx.lineWidth = lineWidth;\n    ctx.strokeStyle = lineColor\n      .replace(\"{green}\", `${Math.floor(255 * (timeDataArray[0] / 128.0))}`)\n      .replace(\"{blue}\", `${Math.floor(255 * (timeDataArray[0] / 128.0))}`);\n    ctx.beginPath();\n\n    for (let i = 0; i < bufferLength; i++) {\n      const v = timeDataArray[i] / 128.0;\n      let y = (v * canvas.height) / 2;\n\n      if (i % arcInterval === 0) {\n        const arcHeight = Math.random() * arcHeightScale * v;\n        ctx.lineTo(x, y);\n        ctx.lineTo(x + 5, y - arcHeight);\n        ctx.lineTo(x + 10, y);\n      } else {\n        if (i === 0) ctx.moveTo(x, y);\n        else ctx.lineTo(x, y);\n      }\n\n      if (i % 20 === 0) {\n        ctx.strokeStyle = lineColor\n          .replace(\"{green}\", `${Math.floor(255 * v)}`)\n          .replace(\"{blue}\", `${Math.floor(255 * v)}`);\n      }\n\n      x += sliceWidth;\n    }\n    ctx.stroke();\n  },\n};\n\nexport default voltaicArcs;\n","import { VisualizerType, visualizerStates } from \"../helpers/visualizerLoader\";\n\nconst voronoiSpectrum: VisualizerType = {\n  name: \"Voronoi Spectrum\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      pointCount = 20,\n      pixelSize = 4,\n      backgroundColor = \"rgba(0, 0, 0, 0.1)\",\n      pointColor = \"hsl({hue}, 100%, {lightness}%)\",\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    let state = visualizerStates.get(\"voronoiSpectrum\") || {};\n    if (!state.points) {\n      state = {\n        points: new Array(pointCount).fill(null).map((_, i) => ({\n          x: 0,\n          y: 0,\n          color: \"\",\n          freqIndex: Math.floor((i * 1024) / pointCount),\n        })),\n        numPoints: pointCount,\n        pixelSize: pixelSize,\n        offscreen: document.createElement(\"canvas\"),\n        offscreenCtx: null as CanvasRenderingContext2D | null,\n      };\n      state.offscreen!.width = canvas.width;\n      state.offscreen!.height = canvas.height;\n      state.offscreenCtx = state.offscreen!.getContext(\"2d\");\n      visualizerStates.set(\"voronoiSpectrum\", state);\n    }\n\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    for (let i = 0; i < state.numPoints!; i++) {\n      const point = state.points![i];\n      point.x = Math.random() * canvas.width;\n      point.y = Math.random() * canvas.height;\n      const value = freqDataArray[point.freqIndex] / 256;\n      point.color = pointColor\n        .replace(\"{hue}\", `${(point.freqIndex * 360) / bufferLength}`)\n        .replace(\"{lightness}\", `${value * 100}`);\n    }\n\n    state.offscreenCtx!.clearRect(0, 0, canvas.width, canvas.height);\n\n    for (let x = 0; x < canvas.width; x += state.pixelSize!) {\n      for (let y = 0; y < canvas.height; y += state.pixelSize!) {\n        let minDist = Infinity;\n        let closestColor = \"\";\n\n        for (let p of state.points!) {\n          const dx = x - p.x;\n          const dy = y - p.y;\n          const dist = dx * dx + dy * dy;\n          if (dist < minDist) {\n            minDist = dist;\n            closestColor = p.color;\n          }\n        }\n\n        state.offscreenCtx!.fillStyle = closestColor;\n        state.offscreenCtx!.fillRect(x, y, state.pixelSize!, state.pixelSize!);\n      }\n    }\n\n    ctx.drawImage(state.offscreen!, 0, 0);\n  },\n};\n\nexport default voronoiSpectrum;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst vortexSpectrogram: VisualizerType = {\n  name: \"Vortex Spectrogram\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      pointColor = \"hsla({hue}, 90%, {lightness}%, {alpha})\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      pointSize = 2,\n      vortexScale = 0.5,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n    const maxRadius = Math.min(centerX, centerY);\n\n    for (let i = 0; i < bufferLength; i++) {\n      const amplitude = freqDataArray[i] / 256.0;\n      const angle = (i * 8 * Math.PI) / bufferLength;\n      const radius =\n        (i / bufferLength) * maxRadius * (1 + amplitude * vortexScale);\n\n      const x = centerX + radius * Math.cos(angle);\n      const y = centerY + radius * Math.sin(angle);\n\n      ctx.fillStyle = pointColor\n        .replace(\"{hue}\", `${(i * 360) / bufferLength}`)\n        .replace(\"{lightness}\", `${40 + amplitude * 60}`)\n        .replace(\"{alpha}\", `${0.1 + amplitude * 0.6}`);\n      ctx.beginPath();\n      ctx.arc(x, y, pointSize + amplitude * 4, 0, 2 * Math.PI);\n      ctx.fill();\n    }\n  },\n};\n\nexport default vortexSpectrogram;\n","import { VisualizerType, visualizerStates } from \"../helpers/visualizerLoader\";\n\nconst waterSpectrogram: VisualizerType = {\n  name: \"3D Water Spectrogram\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      lineColor = \"rgba(0, 255, 255, {alpha})\",\n      fillColor = \"rgba(0, 255, 255, {alpha})\",\n      backgroundColor = \"rgba(20, 20, 20, 0.2)\",\n      layerCount = 15,\n      connectionStep = 4,\n      waveAmplitude = 20,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    let state = visualizerStates.get(\"waterSpectrogram\") || {};\n    if (!state.config) {\n      state.config = {\n        layers: layerCount,\n        sinTable: new Float32Array(360),\n        points: [],\n        initialized: false,\n      };\n      for (let i = 0; i < 360; i++) {\n        state.config.sinTable![i] = Math.sin((i * Math.PI) / 180);\n      }\n      state.config.initialized = true;\n      visualizerStates.set(\"waterSpectrogram\", state);\n    }\n\n    analyser.getByteFrequencyData(freqDataArray as any);\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const currentTime = Date.now() / 1000;\n    const points = state.config.points!;\n    const layers = state.config.layers!;\n    const connections = Math.floor(bufferLength / connectionStep);\n\n    if (points.length !== layers) {\n      points.length = 0;\n      for (let z = 0; z < layers; z++) {\n        points[z] = new Array(connections)\n          .fill(null)\n          .map(() => ({ x: 0, y: 0, z: 0, perspective: 0 }));\n      }\n    }\n\n    const widthStep = canvas.width / connections;\n    for (let z = 0; z < layers; z++) {\n      const perspective = 1 - z * 0.05;\n      const zOffset = z * 20;\n      const layerPoints = points[z];\n\n      for (let i = 0; i < connections; i++) {\n        const freq = freqDataArray[i * connectionStep] * perspective;\n        const point = layerPoints[i];\n        point.x = widthStep * i;\n        point.y =\n          canvas.height / 2 +\n          (freq - 128) * 1.5 * perspective +\n          state.config!.sinTable![\n            Math.floor(\n              ((currentTime + z / 2 + i / 10) % (Math.PI * 2)) * (180 / Math.PI)\n            ) % 360\n          ] *\n            waveAmplitude;\n        point.z = zOffset;\n        point.perspective = perspective;\n      }\n    }\n\n    ctx.beginPath();\n    for (let z = layers - 1; z >= 0; z--) {\n      const currentLayer = points[z];\n\n      for (let i = 0; i < connections - 1; i++) {\n        const current = currentLayer[i];\n        const next = currentLayer[i + 1];\n\n        ctx.strokeStyle = lineColor.replace(\n          \"{alpha}\",\n          `${current.perspective * 0.8}`\n        );\n        ctx.lineWidth = current.perspective * 2;\n        ctx.moveTo(current.x, current.y);\n        ctx.lineTo(next.x, next.y);\n      }\n\n      if (z > 0) {\n        const previousLayer = points[z - 1];\n        ctx.strokeStyle = lineColor.replace(\n          \"{alpha}\",\n          `${currentLayer[0].perspective * 0.4}`\n        );\n        for (let i = 0; i < connections; i += 2) {\n          const current = currentLayer[i];\n          const previous = previousLayer[i];\n          ctx.moveTo(current.x, current.y);\n          ctx.lineTo(previous.x, previous.y);\n        }\n      }\n    }\n    ctx.stroke();\n\n    ctx.beginPath();\n    for (let z = 0; z < layers; z++) {\n      const currentLayer = points[z];\n      for (let i = 0; i < connections - 1; i++) {\n        const current = currentLayer[i];\n        const next = currentLayer[i + 1];\n        ctx.moveTo(current.x, current.y);\n        ctx.lineTo(next.x, next.y);\n        ctx.lineTo(next.x, canvas.height);\n        ctx.lineTo(current.x, canvas.height);\n      }\n    }\n    ctx.fillStyle = fillColor.replace(\"{alpha}\", \"0.1\");\n    ctx.fill();\n  },\n};\n\nexport default waterSpectrogram;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst waterfall: VisualizerType = {\n  name: \"Waterfall\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      hueBase = 240, // start with blue\n      saturation = 100,\n      lightness = 50,\n      scrollSpeed = 1, // pixel-per-frame scroll\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n\n    // Get frequency data\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    // Scroll canvas up by scrollSpeed pixels\n    const imageData = ctx.getImageData(\n      0,\n      scrollSpeed,\n      canvas.width,\n      canvas.height - scrollSpeed\n    );\n    ctx.putImageData(imageData, 0, 0);\n\n    // Draw new line at the bottom\n    const barWidth = canvas.width / bufferLength;\n\n    for (let i = 0; i < bufferLength; i++) {\n      const value = freqDataArray[i]; // 0 - 255\n      const hue = hueBase - (value / 255) * 240; // more intense = red/yellow\n      const sat = saturation;\n      const light = lightness;\n\n      ctx.fillStyle = `hsl(${hue}, ${sat}%, ${light}%)`;\n      ctx.fillRect(\n        i * barWidth,\n        canvas.height - scrollSpeed,\n        barWidth,\n        scrollSpeed\n      );\n    }\n  },\n};\n\nexport default waterfall;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst waveformRings: VisualizerType = {\n  name: \"Waveform Rings\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      ringColor = \"hsla({hue}, 70%, 50%, 0.5)\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      ringCount = 5,\n      lineWidth = 2,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n    const rings = ringCount;\n\n    for (let ring = 0; ring < rings; ring++) {\n      const baseRadius = (ring + 1) * (Math.min(centerX, centerY) / rings);\n\n      ctx.beginPath();\n      for (let i = 0; i < bufferLength; i++) {\n        const amplitude = freqDataArray[i] / 256.0;\n        const angle = (i * 2 * Math.PI) / bufferLength;\n        const radius = baseRadius + amplitude * 20;\n\n        const x = centerX + radius * Math.cos(angle);\n        const y = centerY + radius * Math.sin(angle);\n\n        if (i === 0) {\n          ctx.moveTo(x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n      }\n      ctx.closePath();\n      ctx.strokeStyle = ringColor.replace(\"{hue}\", `${(ring * 360) / rings}`);\n      ctx.lineWidth = lineWidth;\n      ctx.stroke();\n    }\n  },\n};\n\nexport default waveformRings;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst waveformSpectrum: VisualizerType = {\n  name: \"Waveform Spectrum\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      lineColor = \"rgb(0, 255, 0)\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      lineWidth = 2,\n      glowIntensity = 0.5,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    ctx.beginPath();\n    ctx.moveTo(0, canvas.height / 2);\n\n    for (let i = 0; i < bufferLength; i++) {\n      const x = (i * canvas.width) / bufferLength;\n      const y = (freqDataArray[i] / 256.0) * canvas.height;\n      ctx.lineTo(x, y);\n    }\n\n    ctx.lineWidth = lineWidth;\n    ctx.strokeStyle = lineColor;\n    ctx.shadowBlur = 10 * glowIntensity;\n    ctx.shadowColor = lineColor;\n    ctx.stroke();\n    ctx.shadowBlur = 0;\n  },\n};\n\nexport default waveformSpectrum;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst waveformTunnel: VisualizerType = {\n  name: \"Waveform Tunnel\",\n  dataType: \"time\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    timeDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      lineColor = \"hsl({hue}, 100%, 50%)\",\n      backgroundColor = \"rgba(0, 0, 0, 0.1)\",\n      lineWidth = 2,\n      radiusStep = 10,\n    } = settings;\n\n    if (dataType !== \"time\") return;\n    analyser.getByteTimeDomainData(timeDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n    const maxRadius = Math.min(centerX, centerY);\n\n    for (let radius = maxRadius; radius > 0; radius -= radiusStep) {\n      ctx.beginPath();\n      for (let i = 0; i < bufferLength; i++) {\n        const angle = (i * 2 * Math.PI) / bufferLength;\n        const value = timeDataArray[i] / 128.0 - 1;\n        const r = radius + value * 20;\n        const x = centerX + r * Math.cos(angle);\n        const y = centerY + r * Math.sin(angle);\n\n        if (i === 0) ctx.moveTo(x, y);\n        else ctx.lineTo(x, y);\n      }\n      ctx.closePath();\n      ctx.strokeStyle = lineColor.replace(\n        \"{hue}\",\n        `${(radius * 360) / maxRadius}`\n      );\n      ctx.lineWidth = lineWidth;\n      ctx.stroke();\n    }\n  },\n};\n\nexport default waveformTunnel;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst interferenceSpectrogram: VisualizerType = {\n  name: \"Wave Interference Spectrogram\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      pointColor = \"hsla({hue}, 70%, 50%, {alpha})\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      pointSize = 2,\n      waveSpacing = 20,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    for (let i = 0; i < bufferLength; i++) {\n      const x = (i * canvas.width) / bufferLength;\n      const amplitude = freqDataArray[i] / 256.0;\n\n      for (let j = 0; j < canvas.height; j += waveSpacing) {\n        const wave1 = Math.sin(x / 50 + amplitude * 10) * 10;\n        const wave2 = Math.cos(x / 30) * 10;\n        const interference = wave1 + wave2;\n\n        ctx.fillStyle = pointColor\n          .replace(\"{hue}\", `${j + interference * 10}`)\n          .replace(\"{alpha}\", `${amplitude}`);\n        ctx.beginPath();\n        ctx.arc(x, j + interference, pointSize, 0, 2 * Math.PI);\n        ctx.fill();\n      }\n    }\n  },\n};\n\nexport default interferenceSpectrogram;\n","import { VisualizerType } from \"../helpers/visualizerLoader\";\n\nconst weatherSpectrogram: VisualizerType = {\n  name: \"Weather Pattern Spectrogram\",\n  dataType: \"frequency\",\n  draw: function (\n    analyser,\n    canvas,\n    ctx,\n    bufferLength,\n    freqDataArray,\n    dataType,\n    settings = {}\n  ) {\n    const {\n      cloudColor = \"rgba(255, 255, 255, {alpha})\",\n      backgroundColor = \"rgb(20, 20, 20)\",\n      cloudHeight = 0.33,\n      curveScale = 100,\n    } = settings;\n\n    if (dataType !== \"frequency\") return;\n    analyser.getByteFrequencyData(freqDataArray as any);\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    const height = canvas.height * cloudHeight;\n    for (let i = 0; i < bufferLength; i++) {\n      const x = (i * canvas.width) / bufferLength;\n      const amplitude = freqDataArray[i] / 256.0;\n\n      ctx.fillStyle = cloudColor.replace(\"{alpha}\", `${amplitude}`);\n      ctx.beginPath();\n      ctx.moveTo(x, height);\n      ctx.quadraticCurveTo(\n        x + 10,\n        height - amplitude * curveScale,\n        x + 20,\n        height\n      );\n      ctx.fill();\n    }\n  },\n};\n\nexport default weatherSpectrogram;\n"],"file":"assets/visualizers-D-qNxZFn.js"}